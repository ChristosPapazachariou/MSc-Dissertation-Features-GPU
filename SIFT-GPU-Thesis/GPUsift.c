/***********************************************************************************************************************
This file is part of "SIFT-GPU-Thesis" project.
 * Copyright (C) 2015 {Christos Papazachariou} <{christospapazachariou@gmail.com}>
 * University of Piraeus- MSc program: Advanced Information Systems ("Embedded System Technologies" branch).
 * Partial or otherwise use of this project and/or source code is permitted only for educational and academic purposes.
 * Partial or otherwise use of this project and/or source code for commercial or militay applications is prohibited.
***********************************************************************************************************************/

#include "sift.h"
#include "timer.h"
#include "img_io.h"

#include "cuda.h"
#include "cuda_runtime.h"
#include "MYtimer.h"
#include "gpusift.h"

//OPENCV IN-OUT HANDLING INCLUDES
#include "ioocv.h"

#undef DUMP_OCTAVE
#undef DUMP_SCALESPACE
#undef DUMP_DOG

void
GPUsift(unsigned char* img, int w, int h, char* out_filename) {

	IplImage* ocvTemp;
  
    /************************
     * Common Variables
     ***********************/
    Timer totalTime;
    int i, j;
	
	char labelcall [100];

#if (defined DUMP_OCTAVE || defined DUMP_SCALESPACE || defined DUMP_DOG)
    // file name
    char tmpfile[10];
#endif
    /************************
     * Global Variables
     ***********************/
    // number of total octaves
    int O;
    // number of scales per octaves
    int S;
    // width of each octave
    int octavesW[MAX_O];
    // height of each octave
    int octavesH[MAX_O];
    // sigma at each scale
    float sigma0 = 1.6f;
    float sigmas[MAX_O][MAX_S];
    // number of keys in linked list
    int keyN = 0;
    FILE *skey;
    /************************
     * Data Structures
     ***********************/

    // octaves generated by down sampling
    unsigned char* octaves[MAX_O];
    // scale space
    float* scaleSpace[MAX_O][MAX_S];
    // difference of gaussians
    float* dog[MAX_O][MAX_S-1];
    // extreme points
    pointList* keyHead, * keyPtr;

    /************************
     * Variable computation
     ***********************/

	cudaFree(0);	//initialize cuda device -dummy call

	logtime("GPU CPU-variable computation start");
    // number of octaves (skip last two level)
    O = (int)(log2( (w < h) ? (float)w : (float)h))-2;
    // scales per octaves (epirical number)
    S = 6;
    // width of octaves at each level
    octavesW[0] = w;
    for(i = 1; i < O; i++){
        octavesW[i] = octavesW[i-1]/2;
    }
    // height of octaves at each level
    octavesH[0] = h;
    for(i = 1; i < O; i++){
        octavesH[i] = octavesH[i-1]/2;
    }
    // gaussian sigmas at each scale
    for(i = 0; i < O; i++){
        for(j = 0; j < S; j++){
            sigmas[i][j] = sigma0 * pow(sqrt(2.0f), (float)j/(float)(S-3) );
        }
    }
	logtime("GPU CPU-variable computation end");

#if VERBOSE == 1
    printf("Image size: %dx%d\n", w, h);
    printf("Number of octaves (O):%d\n", O);
    printf("Scales per octave (S):%d\n", S);
    for(i = 0; i < O; i++){
        printf("size of octave level %d: %dx%d\n", i, octavesW[i], octavesH[i]);
    }
#endif

    /*******************************
     * start the timer
     *******************************/
    start_timer(&totalTime);
    /************************
     * Memory Allocation
     ***********************/
	logtime("GPU CPU-malloc start");
    // octaves
    for(i = 0; i < O; i++){
        octaves[i] = (unsigned char*)
            malloc(octavesW[i] * octavesH[i] * sizeof(unsigned char));
    }
    // scale space
    for(i = 0; i < O; i++){
        for(j = 0; j < S; j++){
            scaleSpace[i][j] =
                (float*)malloc(octavesW[i] * octavesH[i] * sizeof(float));
        }
    }
    // difference of gaussians
    for(i = 0; i < O; i++){
        for(j = 0; j < S-1; j++){
            dog[i][j] = 
                (float*)malloc( octavesW[i] * octavesH[i] * sizeof(float));
        }
    }
	logtime("GPU CPU-malloc end");
    
    /************************
     * Step 1:
     * Build Octave Base by downsampling
     ***********************/
		printf("\n *** GPU: STEP 1 : BUILD OCTAVE BASE BY DOWNSAMPLING.*** \n");
		logtime("GPU buildOB-start");
	GPUbuildOB(img, octaves, O, S, octavesW, octavesH);
		logtime("GPU buildOB-end");

//OPENCV VIEW/SAVE DEBUG
		for(i=0;i<O;i++){
				sprintf(labelcall,"GPU octave %02d",i);
				openShow(octaves[i],octavesH[i], octavesW[i], labelcall);
				sprintf(labelcall,"producedImages/01GPU octave%02d.jpg",i);
				openSave(octaves[i],octavesH[i], octavesW[i], labelcall);
		}

#ifdef DUMP_OCTAVE
    for(i = 0; i < O; i++){
        sprintf(tmpfile,"%s%d%s", "OB", i, ".pgm");
        write_pgm(octaves[i], octavesW[i], octavesH[i], tmpfile);
    }
#endif

    /************************
     * Step 2:
     * Build Scale Space by Gaussian
     ***********************/
		printf("\n*** GPU: STEP 2 : BUILD SCALE SPACE BY GAUSSIAN.*** \n");
		logtime("GPU buildSS-start");
	GPUbuildSS(octaves, scaleSpace, O, S, octavesW, octavesH, sigmas);
		logtime("GPU buildSS-end");

//OPENCV VIEW/SAVE DEBUG
		for (i=0;i<O;i++){//for each octave
			for (j=0;j<S;j++){
				sprintf(labelcall,"producedImages/02GPUscaleSpace O%02d S%02d.jpg",i,j);
				openSaveFloat(scaleSpace[i][j],labelcall,octavesH[i],octavesW[i]);
				sprintf(labelcall,"GPUsS O%02d S%02d",i,j);
				openShowFloat(scaleSpace[i][j],labelcall,octavesH[i],octavesW[i]);
			}
		}

#ifdef DUMP_SCALESPACE
    for(i = 0; i < O; i++){
        for(j = 0; j < S; j++){
            sprintf(tmpfile, "%s%d%d%s", "SS", i, j, ".pgm");
            write_float_pgm(scaleSpace[i][j],octavesW[i],octavesH[i],tmpfile,1);
        }
    }
#endif

    /************************
     * Step 3:
     * Difference of Gaussians (DoG)
     ***********************/
		printf("\n*** GPU: STEP 3 : DIFFERENCE OF GAUSSIANS.*** \n");
		logtime("GPU DoG-start");
    GPUDoG(dog, scaleSpace, O, S, octavesW, octavesH);
		logtime("GPU DoG-end");

//OPENCV VIEW/SAVE DEBUG
	for (i=0;i<O;i++){//for each octave
		for (j=0;j<S-1;j++){
			sprintf(labelcall,"producedImages/03GPUDoG O%02d S%02d.jpg",i,j);
				openSaveFloat(dog[i][j],labelcall,octavesH[i],octavesW[i]);
				sprintf(labelcall,"GPUDoG O%02d S%02d",i,j);
				openShowFloat(dog[i][j],labelcall,octavesH[i],octavesW[i]);
		}
	}

#ifdef DUMP_DOG
    for(i = 0; i < O; i++){
        for(j = 0; j < S-1; j++){
            sprintf(tmpfile,"%s%d%d%s", "DoG", i, j, ".pgm");
            write_float_pgm(dog[i][j], octavesW[i], octavesH[i], tmpfile, 2);
        }
    }
#endif

    /************************
     * Step 4:
     * Find extreme points
     ***********************/
	printf("\n*** GPU: STEP 4 : EXTREMA SEARCH.*** \n");
    //extreme(&keyHead, &keyN, dog, O, S, octavesW, octavesH);
	GPUextreme(&keyHead, &keyN, dog, O, S, octavesW, octavesH);

    /************************
     * Keypoint Orientation
     ***********************/
	printf("\n*** GPU: STEP 5 : KEYPOINT ORIENTATION.*** \n");
    orientation(keyHead, scaleSpace, sigmas, octavesW, octavesH);
	
#if VERBOSE == 1
    printf("Detect %d keypoints\n", keyN);
    skey = fopen("skey","w");
    keyPtr = keyHead;
    fprintf(skey, "%d\t%d\n", keyN, 4);
		logtime2("GPU- CPU orientation start");
    for(i = 0; i < keyN; i++){
        fprintf(skey, "%f\t%f\t%f\t%f\n", keyPtr->self.x, keyPtr->self.y,
                keyPtr->self.s, keyPtr->self.ori);
        keyPtr = keyPtr->next;
    }
		logtime2("GPU- CPU orientation end");
    fclose(skey);
    printf
        ("Output 4 element descriptor to file: skey\n");
#endif

    /*******************************
     * All actual processing done,
     * stop the timer
     *******************************/
	printf("\n### GPU: PROCCESSING COMPLETE.### \n");
    stop_timer(&totalTime);
    printf("Total time: %f ms\n", get_timer_interval(&totalTime));
    /************************
     * Render Results
     * Draw circle around keypoints
     * (to do: draw the orientation)
     ***********************/
	printf("\n### GPU: RENDERING RESULTS.### \n");
    render(img, out_filename, O, S, octavesW, octavesH, keyHead, keyN, sigmas);

    /************************
     * Free Memory
     ***********************/
	printf("\n### GPU: clearing memory.### \n");
    for(i = 0; i < O; i++){
        free(octaves[i]);
        for(j = 0; j < S; j++){
            free(scaleSpace[i][j]);
            if(j < S-1){
                free(dog[i][j]);
            }
        }
    }
	printf("---GPU: SIFT COMPLETE--- \n");
}// GPUsift()
