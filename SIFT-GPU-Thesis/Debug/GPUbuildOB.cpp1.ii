#line 1 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"

































































#line 67 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"









#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"









#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"







#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"

#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"













#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"




#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"





#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"







#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"





#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"





#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"





#line 148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 





#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


















#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"










#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"














#pragma once



































































































































#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"





#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"



#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"


#line 1 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"












#pragma once








#line 23 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
#line 24 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"





typedef __w64 unsigned int   size_t;
#line 31 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

#line 33 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
















#line 50 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"


namespace vc_attributes
{
#line 55 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

enum YesNoMaybe
{
	
	No = 0x0fff0001,
	Maybe = 0x0fff0010,
	Yes = 0x0fff0100
};

typedef enum YesNoMaybe YesNoMaybe;

enum AccessType
{
	NoAccess = 0,
	Read = 1,
	Write = 2,
	ReadWrite = 3
};

typedef enum AccessType AccessType;



[repeatable]
[source_annotation_attribute( Parameter )]
struct PreAttribute
{

	PreAttribute();
#line 85 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

	unsigned int Deref;
	YesNoMaybe Valid;
	YesNoMaybe Null;
	YesNoMaybe Tainted;
	AccessType Access;
	size_t ValidElementsConst;
	size_t ValidBytesConst;
	const wchar_t* ValidElements;
	const wchar_t* ValidBytes;
	const wchar_t* ValidElementsLength;
	const wchar_t* ValidBytesLength;
	size_t WritableElementsConst;
	size_t WritableBytesConst;
	const wchar_t* WritableElements;
	const wchar_t* WritableBytes;
	const wchar_t* WritableElementsLength;
	const wchar_t* WritableBytesLength;
	size_t ElementSizeConst;
	const wchar_t* ElementSize;
	YesNoMaybe NullTerminated;
	const wchar_t* Condition;
};

[repeatable]
[source_annotation_attribute( Parameter|ReturnValue )]
struct PostAttribute
{

	PostAttribute();
#line 116 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

	unsigned int Deref;
	YesNoMaybe Valid;
	YesNoMaybe Null;
	YesNoMaybe Tainted;
	AccessType Access;
	size_t ValidElementsConst;
	size_t ValidBytesConst;
	const wchar_t* ValidElements;
	const wchar_t* ValidBytes;
	const wchar_t* ValidElementsLength;
	const wchar_t* ValidBytesLength;
	size_t WritableElementsConst;
	size_t WritableBytesConst;
	const wchar_t* WritableElements;
	const wchar_t* WritableBytes;
	const wchar_t* WritableElementsLength;
	const wchar_t* WritableBytesLength;
	size_t ElementSizeConst;
	const wchar_t* ElementSize;
	YesNoMaybe NullTerminated;
	YesNoMaybe MustCheck;
	const wchar_t* Condition;
};

[source_annotation_attribute( Parameter )]
struct FormatStringAttribute
{

	FormatStringAttribute();
#line 147 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

	const wchar_t* Style;
	const wchar_t* UnformattedAlternative;
};

[repeatable]
[source_annotation_attribute( ReturnValue )]
struct InvalidCheckAttribute
{

	InvalidCheckAttribute();
#line 159 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

	long Value;
};

[source_annotation_attribute( Method )]
struct SuccessAttribute
{

	SuccessAttribute();
#line 169 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

	const wchar_t* Condition;
};

[repeatable]
[source_annotation_attribute( Parameter )]
struct PreBoundAttribute
{

	PreBoundAttribute();
#line 180 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
	unsigned int Deref;
};

[repeatable]
[source_annotation_attribute( Parameter|ReturnValue )]
struct PostBoundAttribute
{

	PostBoundAttribute();
#line 190 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
	unsigned int Deref;
};

[repeatable]
[source_annotation_attribute( Parameter )]
struct PreRangeAttribute
{

	PreRangeAttribute();
#line 200 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
	unsigned int Deref;
	const char* MinVal;
	const char* MaxVal;
};

[repeatable]
[source_annotation_attribute( Parameter|ReturnValue )]
struct PostRangeAttribute
{

	PostRangeAttribute();
#line 212 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
	unsigned int Deref;
	const char* MinVal;
	const char* MaxVal;
};

#line 218 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"


};  
#line 222 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"






















typedef ::vc_attributes::YesNoMaybe SA_YesNoMaybe;
const ::vc_attributes::YesNoMaybe SA_Yes = ::vc_attributes::Yes;
const ::vc_attributes::YesNoMaybe SA_No = ::vc_attributes::No;
const ::vc_attributes::YesNoMaybe SA_Maybe = ::vc_attributes::Maybe;

typedef ::vc_attributes::AccessType SA_AccessType;
const ::vc_attributes::AccessType SA_NoAccess = ::vc_attributes::NoAccess;
const ::vc_attributes::AccessType SA_Read = ::vc_attributes::Read;
const ::vc_attributes::AccessType SA_Write = ::vc_attributes::Write;
const ::vc_attributes::AccessType SA_ReadWrite = ::vc_attributes::ReadWrite;


typedef ::vc_attributes::PreAttribute          SA_Pre;
typedef ::vc_attributes::PostAttribute         SA_Post;
typedef ::vc_attributes::FormatStringAttribute SA_FormatString;
typedef ::vc_attributes::InvalidCheckAttribute SA_InvalidCheck; 
typedef ::vc_attributes::SuccessAttribute      SA_Success;
typedef ::vc_attributes::PreBoundAttribute     SA_PreBound;
typedef ::vc_attributes::PostBoundAttribute    SA_PostBound;
typedef ::vc_attributes::PreRangeAttribute     SA_PreRange;
typedef ::vc_attributes::PostRangeAttribute    SA_PostRange;
#line 266 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"















#line 282 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

#line 284 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"




















#line 305 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"


#line 308 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"

#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"
#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"







































































































































































































































































































































































































































































































































































































































































                                                




                                                


























































































































































































































#line 1034 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"































































































#line 1130 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"



































































































#line 1230 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"



















































#line 1282 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"



















































































































































































































#line 1494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"
extern "C" {




#line 1500 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"




























































































































































































































#line 1721 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 1755 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"



































































































































































































































    
    
#line 1985 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"






#line 1992 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"
#line 1993 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"


}
#line 1997 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sal.h"



#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#pragma pack(push,8)

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"












#pragma once






#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"








#pragma pack(push,8)


extern "C" {
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"








#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"





typedef __w64 unsigned int   uintptr_t;
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"

#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"





typedef char *  va_list;
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"





#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"











#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"


#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"













#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"












































#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"


}
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"

#pragma pack(pop)

#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


extern "C" {
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"







#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"








#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"










#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"









#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"







#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


 

#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
  
 #line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"










#line 189 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

















#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"








#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"










#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"










#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"







#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



 
  
 



#line 333 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 334 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


 
  
  
 



#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


 
  
   
  

#line 353 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
 



#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


 
  
 



#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


 
  
 



#line 378 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 379 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 396 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"












typedef size_t rsize_t;

#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 413 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





typedef __w64 int            intptr_t;
#line 420 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 422 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














typedef __w64 int            ptrdiff_t;
#line 438 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"







typedef unsigned short wint_t;
typedef unsigned short wctype_t;

#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


















typedef int errno_t;
#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


typedef __w64 long __time32_t;   

#line 476 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


typedef __int64 __time64_t;     

#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





typedef __time64_t time_t;      
#line 488 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 490 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"







#line 498 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 499 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 506 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 507 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 515 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"





#line 521 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 525 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"




#line 530 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"










 __declspec(dllimport) void __cdecl _invalid_parameter(   const wchar_t *,    const wchar_t *,    const wchar_t *, unsigned int, uintptr_t);



#line 548 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

__declspec(dllimport) __declspec(noreturn)
void __cdecl _invoke_watson(   const wchar_t *,    const wchar_t *,    const wchar_t *, unsigned int, uintptr_t);


 
  
 #line 556 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"












#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"







#line 577 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


































































































































































#line 740 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 741 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1807 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"















































































































































#line 1951 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#line 1952 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;

#line 1973 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; 
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;

#line 2002 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"


}
#line 2006 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 2010 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 2012 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 2016 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 2018 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 2022 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 2024 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"






#line 2031 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"



#line 2035 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#pragma pack(pop)

#line 2039 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"

#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"



#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"

#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"

#line 158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_config.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"







#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"





















































































#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"










#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"








































#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"










#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"






#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"




#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"










#line 174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"













        





#line 194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"








#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"


#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"







enum __declspec(__device_builtin__) cudaRoundMode
{
    cudaRoundNearest,
    cudaRoundZero,
    cudaRoundPosInf,
    cudaRoundMinInf
};

#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"
















#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"














#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"
















#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"









































#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"






#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"







#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"
































#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits.h"
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"


extern "C" {
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"







#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"




namespace std { typedef decltype(__nullptr) nullptr_t; }
using ::std::nullptr_t;
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"





__declspec(dllimport) extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno(  int _Value);
errno_t __cdecl _get_errno(  int * _Value);
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"








#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"









#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);


}
#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"

#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
#line 72 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"













































#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"










enum __declspec(__device_builtin__) cudaError
{
    




    cudaSuccess                           =      0,
  
    



    cudaErrorMissingConfiguration         =      1,
  
    



    cudaErrorMemoryAllocation             =      2,
  
    



    cudaErrorInitializationError          =      3,
  
    







    cudaErrorLaunchFailure                =      4,
  
    






    cudaErrorPriorLaunchFailure           =      5,
  
    







    cudaErrorLaunchTimeout                =      6,
  
    






    cudaErrorLaunchOutOfResources         =      7,
  
    



    cudaErrorInvalidDeviceFunction        =      8,
  
    






    cudaErrorInvalidConfiguration         =      9,
  
    



    cudaErrorInvalidDevice                =     10,
  
    



    cudaErrorInvalidValue                 =     11,
  
    



    cudaErrorInvalidPitchValue            =     12,
  
    



    cudaErrorInvalidSymbol                =     13,
  
    


    cudaErrorMapBufferObjectFailed        =     14,
  
    


    cudaErrorUnmapBufferObjectFailed      =     15,
  
    



    cudaErrorInvalidHostPointer           =     16,
  
    



    cudaErrorInvalidDevicePointer         =     17,
  
    



    cudaErrorInvalidTexture               =     18,
  
    



    cudaErrorInvalidTextureBinding        =     19,
  
    




    cudaErrorInvalidChannelDescriptor     =     20,
  
    



    cudaErrorInvalidMemcpyDirection       =     21,
  
    







    cudaErrorAddressOfConstant            =     22,
  
    






    cudaErrorTextureFetchFailed           =     23,
  
    






    cudaErrorTextureNotBound              =     24,
  
    






    cudaErrorSynchronizationError         =     25,
  
    



    cudaErrorInvalidFilterSetting         =     26,
  
    



    cudaErrorInvalidNormSetting           =     27,
  
    





    cudaErrorMixedDeviceExecution         =     28,
  
    




    cudaErrorCudartUnloading              =     29,
  
    


    cudaErrorUnknown                      =     30,

    





    cudaErrorNotYetImplemented            =     31,
  
    






    cudaErrorMemoryValueTooLarge          =     32,
  
    




    cudaErrorInvalidResourceHandle        =     33,
  
    





    cudaErrorNotReady                     =     34,
  
    




    cudaErrorInsufficientDriver           =     35,
  
    










    cudaErrorSetOnActiveProcess           =     36,
  
    



    cudaErrorInvalidSurface               =     37,
  
    



    cudaErrorNoDevice                     =     38,
  
    



    cudaErrorECCUncorrectable             =     39,
  
    


    cudaErrorSharedObjectSymbolNotFound   =     40,
  
    


    cudaErrorSharedObjectInitFailed       =     41,
  
    



    cudaErrorUnsupportedLimit             =     42,
  
    



    cudaErrorDuplicateVariableName        =     43,
  
    



    cudaErrorDuplicateTextureName         =     44,
  
    



    cudaErrorDuplicateSurfaceName         =     45,
  
    







    cudaErrorDevicesUnavailable           =     46,
  
    


    cudaErrorInvalidKernelImage           =     47,
  
    





    cudaErrorNoKernelImageForDevice       =     48,
  
    










    cudaErrorIncompatibleDriverContext    =     49,
      
    




    cudaErrorPeerAccessAlreadyEnabled     =     50,
    
    




    cudaErrorPeerAccessNotEnabled         =     51,
    
    



    cudaErrorDeviceAlreadyInUse           =     54,

    




    cudaErrorProfilerDisabled             =     55,

    





    cudaErrorProfilerNotInitialized       =     56,

    




    cudaErrorProfilerAlreadyStarted       =     57,

    




     cudaErrorProfilerAlreadyStopped       =    58,

    





    cudaErrorAssert                        =    59,
  
    




    cudaErrorTooManyPeers                 =     60,
  
    



    cudaErrorHostMemoryAlreadyRegistered  =     61,
        
    



    cudaErrorHostMemoryNotRegistered      =     62,

    


    cudaErrorOperatingSystem              =     63,

    



    cudaErrorPeerAccessUnsupported        =     64,

    




    cudaErrorLaunchMaxDepthExceeded       =     65,

    





    cudaErrorLaunchFileScopedTex          =     66,

    





    cudaErrorLaunchFileScopedSurf         =     67,

    












    cudaErrorSyncDepthExceeded            =     68,

    









    cudaErrorLaunchPendingCountExceeded   =     69,
    
    


    cudaErrorNotPermitted                 =     70,

    



    cudaErrorNotSupported                 =     71,

    






    cudaErrorHardwareStackError           =     72,

    





    cudaErrorIllegalInstruction           =     73,

    






    cudaErrorMisalignedAddress            =     74,

    








    cudaErrorInvalidAddressSpace          =     75,

    





    cudaErrorInvalidPc                    =     76,

    





    cudaErrorIllegalAddress               =     77,

    



    cudaErrorInvalidPtx                   =     78,

    


    cudaErrorInvalidGraphicsContext       =     79,


    


    cudaErrorStartupFailure               =   0x7f,

    





    cudaErrorApiFailureBase               =  10000
};




enum __declspec(__device_builtin__) cudaChannelFormatKind
{
    cudaChannelFormatKindSigned           =   0,      
    cudaChannelFormatKindUnsigned         =   1,      
    cudaChannelFormatKindFloat            =   2,      
    cudaChannelFormatKindNone             =   3       
};




struct __declspec(__device_builtin__) cudaChannelFormatDesc
{
    int                        x; 
    int                        y; 
    int                        z; 
    int                        w; 
    enum cudaChannelFormatKind f; 
};




typedef struct cudaArray *cudaArray_t;




typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;




typedef struct cudaMipmappedArray *cudaMipmappedArray_t;




typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;




enum __declspec(__device_builtin__) cudaMemoryType
{
    cudaMemoryTypeHost   = 1, 
    cudaMemoryTypeDevice = 2  
};




enum __declspec(__device_builtin__) cudaMemcpyKind
{
    cudaMemcpyHostToHost          =   0,      
    cudaMemcpyHostToDevice        =   1,      
    cudaMemcpyDeviceToHost        =   2,      
    cudaMemcpyDeviceToDevice      =   3,      
    cudaMemcpyDefault             =   4       
};






struct __declspec(__device_builtin__) cudaPitchedPtr
{
    void   *ptr;      
    size_t  pitch;    
    size_t  xsize;    
    size_t  ysize;    
};






struct __declspec(__device_builtin__) cudaExtent
{
    size_t width;     
    size_t height;    
    size_t depth;     
};






struct __declspec(__device_builtin__) cudaPos
{
    size_t x;     
    size_t y;     
    size_t z;     
};




struct __declspec(__device_builtin__) cudaMemcpy3DParms
{
    cudaArray_t            srcArray;  
    struct cudaPos         srcPos;    
    struct cudaPitchedPtr  srcPtr;    
  
    cudaArray_t            dstArray;  
    struct cudaPos         dstPos;    
    struct cudaPitchedPtr  dstPtr;    
  
    struct cudaExtent      extent;    
    enum cudaMemcpyKind    kind;      
};




struct __declspec(__device_builtin__) cudaMemcpy3DPeerParms
{
    cudaArray_t            srcArray;  
    struct cudaPos         srcPos;    
    struct cudaPitchedPtr  srcPtr;    
    int                    srcDevice; 
  
    cudaArray_t            dstArray;  
    struct cudaPos         dstPos;    
    struct cudaPitchedPtr  dstPtr;    
    int                    dstDevice; 
  
    struct cudaExtent      extent;    
};




struct cudaGraphicsResource;




enum __declspec(__device_builtin__) cudaGraphicsRegisterFlags
{
    cudaGraphicsRegisterFlagsNone             = 0,  
    cudaGraphicsRegisterFlagsReadOnly         = 1,   
    cudaGraphicsRegisterFlagsWriteDiscard     = 2,  
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,  
    cudaGraphicsRegisterFlagsTextureGather    = 8   
};




enum __declspec(__device_builtin__) cudaGraphicsMapFlags
{
    cudaGraphicsMapFlagsNone         = 0,  
    cudaGraphicsMapFlagsReadOnly     = 1,  
    cudaGraphicsMapFlagsWriteDiscard = 2   
};




enum __declspec(__device_builtin__) cudaGraphicsCubeFace 
{
    cudaGraphicsCubeFacePositiveX = 0x00, 
    cudaGraphicsCubeFaceNegativeX = 0x01, 
    cudaGraphicsCubeFacePositiveY = 0x02, 
    cudaGraphicsCubeFaceNegativeY = 0x03, 
    cudaGraphicsCubeFacePositiveZ = 0x04, 
    cudaGraphicsCubeFaceNegativeZ = 0x05  
};




enum __declspec(__device_builtin__) cudaResourceType
{
    cudaResourceTypeArray          = 0x00, 
    cudaResourceTypeMipmappedArray = 0x01, 
    cudaResourceTypeLinear         = 0x02, 
    cudaResourceTypePitch2D        = 0x03  
};




enum __declspec(__device_builtin__) cudaResourceViewFormat
{
    cudaResViewFormatNone                      = 0x00, 
    cudaResViewFormatUnsignedChar1             = 0x01, 
    cudaResViewFormatUnsignedChar2             = 0x02, 
    cudaResViewFormatUnsignedChar4             = 0x03, 
    cudaResViewFormatSignedChar1               = 0x04, 
    cudaResViewFormatSignedChar2               = 0x05, 
    cudaResViewFormatSignedChar4               = 0x06, 
    cudaResViewFormatUnsignedShort1            = 0x07, 
    cudaResViewFormatUnsignedShort2            = 0x08, 
    cudaResViewFormatUnsignedShort4            = 0x09, 
    cudaResViewFormatSignedShort1              = 0x0a, 
    cudaResViewFormatSignedShort2              = 0x0b, 
    cudaResViewFormatSignedShort4              = 0x0c, 
    cudaResViewFormatUnsignedInt1              = 0x0d, 
    cudaResViewFormatUnsignedInt2              = 0x0e, 
    cudaResViewFormatUnsignedInt4              = 0x0f, 
    cudaResViewFormatSignedInt1                = 0x10, 
    cudaResViewFormatSignedInt2                = 0x11, 
    cudaResViewFormatSignedInt4                = 0x12, 
    cudaResViewFormatHalf1                     = 0x13, 
    cudaResViewFormatHalf2                     = 0x14, 
    cudaResViewFormatHalf4                     = 0x15, 
    cudaResViewFormatFloat1                    = 0x16, 
    cudaResViewFormatFloat2                    = 0x17, 
    cudaResViewFormatFloat4                    = 0x18, 
    cudaResViewFormatUnsignedBlockCompressed1  = 0x19, 
    cudaResViewFormatUnsignedBlockCompressed2  = 0x1a, 
    cudaResViewFormatUnsignedBlockCompressed3  = 0x1b, 
    cudaResViewFormatUnsignedBlockCompressed4  = 0x1c, 
    cudaResViewFormatSignedBlockCompressed4    = 0x1d, 
    cudaResViewFormatUnsignedBlockCompressed5  = 0x1e, 
    cudaResViewFormatSignedBlockCompressed5    = 0x1f, 
    cudaResViewFormatUnsignedBlockCompressed6H = 0x20, 
    cudaResViewFormatSignedBlockCompressed6H   = 0x21, 
    cudaResViewFormatUnsignedBlockCompressed7  = 0x22  
};




struct __declspec(__device_builtin__) cudaResourceDesc {
	enum cudaResourceType resType;             
	
	union {
		struct {
			cudaArray_t array;                 
		} array;
        struct {
            cudaMipmappedArray_t mipmap;       
        } mipmap;
		struct {
			void *devPtr;                      
			struct cudaChannelFormatDesc desc; 
			size_t sizeInBytes;                
		} linear;
		struct {
			void *devPtr;                      
			struct cudaChannelFormatDesc desc; 
			size_t width;                      
			size_t height;                     
			size_t pitchInBytes;               
		} pitch2D;
	} res;
};




struct __declspec(__device_builtin__) cudaResourceViewDesc
{
    enum cudaResourceViewFormat format;           
    size_t                      width;            
    size_t                      height;           
    size_t                      depth;            
    unsigned int                firstMipmapLevel; 
    unsigned int                lastMipmapLevel;  
    unsigned int                firstLayer;       
    unsigned int                lastLayer;        
};




struct __declspec(__device_builtin__) cudaPointerAttributes
{
    



    enum cudaMemoryType memoryType;

    








    int device;

    



    void *devicePointer;

    



    void *hostPointer;

    


    int isManaged;
};




struct __declspec(__device_builtin__) cudaFuncAttributes
{
   




   size_t sharedSizeBytes;

   



   size_t constSizeBytes;

   


   size_t localSizeBytes;

   




   int maxThreadsPerBlock;

   


   int numRegs;

   




   int ptxVersion;

   




   int binaryVersion;

   



   int cacheModeCA;
};




enum __declspec(__device_builtin__) cudaFuncCache
{
    cudaFuncCachePreferNone   = 0,    
    cudaFuncCachePreferShared = 1,    
    cudaFuncCachePreferL1     = 2,    
    cudaFuncCachePreferEqual  = 3     
};





enum __declspec(__device_builtin__) cudaSharedMemConfig
{
    cudaSharedMemBankSizeDefault   = 0,
    cudaSharedMemBankSizeFourByte  = 1,
    cudaSharedMemBankSizeEightByte = 2
};




enum __declspec(__device_builtin__) cudaComputeMode
{
    cudaComputeModeDefault          = 0,  
    cudaComputeModeExclusive        = 1,  
    cudaComputeModeProhibited       = 2,  
    cudaComputeModeExclusiveProcess = 3   
};




enum __declspec(__device_builtin__) cudaLimit
{
    cudaLimitStackSize                    = 0x00, 
    cudaLimitPrintfFifoSize               = 0x01, 
    cudaLimitMallocHeapSize               = 0x02, 
    cudaLimitDevRuntimeSyncDepth          = 0x03, 
    cudaLimitDevRuntimePendingLaunchCount = 0x04  
};




enum __declspec(__device_builtin__) cudaOutputMode
{
    cudaKeyValuePair    = 0x00, 
    cudaCSV             = 0x01  
};




enum __declspec(__device_builtin__) cudaDeviceAttr
{
    cudaDevAttrMaxThreadsPerBlock             = 1,  
    cudaDevAttrMaxBlockDimX                   = 2,  
    cudaDevAttrMaxBlockDimY                   = 3,  
    cudaDevAttrMaxBlockDimZ                   = 4,  
    cudaDevAttrMaxGridDimX                    = 5,  
    cudaDevAttrMaxGridDimY                    = 6,  
    cudaDevAttrMaxGridDimZ                    = 7,  
    cudaDevAttrMaxSharedMemoryPerBlock        = 8,  
    cudaDevAttrTotalConstantMemory            = 9,  
    cudaDevAttrWarpSize                       = 10, 
    cudaDevAttrMaxPitch                       = 11, 
    cudaDevAttrMaxRegistersPerBlock           = 12, 
    cudaDevAttrClockRate                      = 13, 
    cudaDevAttrTextureAlignment               = 14, 
    cudaDevAttrGpuOverlap                     = 15, 
    cudaDevAttrMultiProcessorCount            = 16, 
    cudaDevAttrKernelExecTimeout              = 17, 
    cudaDevAttrIntegrated                     = 18, 
    cudaDevAttrCanMapHostMemory               = 19, 
    cudaDevAttrComputeMode                    = 20, 
    cudaDevAttrMaxTexture1DWidth              = 21, 
    cudaDevAttrMaxTexture2DWidth              = 22, 
    cudaDevAttrMaxTexture2DHeight             = 23, 
    cudaDevAttrMaxTexture3DWidth              = 24, 
    cudaDevAttrMaxTexture3DHeight             = 25, 
    cudaDevAttrMaxTexture3DDepth              = 26, 
    cudaDevAttrMaxTexture2DLayeredWidth       = 27, 
    cudaDevAttrMaxTexture2DLayeredHeight      = 28, 
    cudaDevAttrMaxTexture2DLayeredLayers      = 29, 
    cudaDevAttrSurfaceAlignment               = 30, 
    cudaDevAttrConcurrentKernels              = 31, 
    cudaDevAttrEccEnabled                     = 32, 
    cudaDevAttrPciBusId                       = 33, 
    cudaDevAttrPciDeviceId                    = 34, 
    cudaDevAttrTccDriver                      = 35, 
    cudaDevAttrMemoryClockRate                = 36, 
    cudaDevAttrGlobalMemoryBusWidth           = 37, 
    cudaDevAttrL2CacheSize                    = 38, 
    cudaDevAttrMaxThreadsPerMultiProcessor    = 39, 
    cudaDevAttrAsyncEngineCount               = 40, 
    cudaDevAttrUnifiedAddressing              = 41,     
    cudaDevAttrMaxTexture1DLayeredWidth       = 42, 
    cudaDevAttrMaxTexture1DLayeredLayers      = 43, 
    cudaDevAttrMaxTexture2DGatherWidth        = 45, 
    cudaDevAttrMaxTexture2DGatherHeight       = 46, 
    cudaDevAttrMaxTexture3DWidthAlt           = 47, 
    cudaDevAttrMaxTexture3DHeightAlt          = 48, 
    cudaDevAttrMaxTexture3DDepthAlt           = 49, 
    cudaDevAttrPciDomainId                    = 50, 
    cudaDevAttrTexturePitchAlignment          = 51, 
    cudaDevAttrMaxTextureCubemapWidth         = 52, 
    cudaDevAttrMaxTextureCubemapLayeredWidth  = 53, 
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54, 
    cudaDevAttrMaxSurface1DWidth              = 55, 
    cudaDevAttrMaxSurface2DWidth              = 56, 
    cudaDevAttrMaxSurface2DHeight             = 57, 
    cudaDevAttrMaxSurface3DWidth              = 58, 
    cudaDevAttrMaxSurface3DHeight             = 59, 
    cudaDevAttrMaxSurface3DDepth              = 60, 
    cudaDevAttrMaxSurface1DLayeredWidth       = 61, 
    cudaDevAttrMaxSurface1DLayeredLayers      = 62, 
    cudaDevAttrMaxSurface2DLayeredWidth       = 63, 
    cudaDevAttrMaxSurface2DLayeredHeight      = 64, 
    cudaDevAttrMaxSurface2DLayeredLayers      = 65, 
    cudaDevAttrMaxSurfaceCubemapWidth         = 66, 
    cudaDevAttrMaxSurfaceCubemapLayeredWidth  = 67, 
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68, 
    cudaDevAttrMaxTexture1DLinearWidth        = 69, 
    cudaDevAttrMaxTexture2DLinearWidth        = 70, 
    cudaDevAttrMaxTexture2DLinearHeight       = 71, 
    cudaDevAttrMaxTexture2DLinearPitch        = 72, 
    cudaDevAttrMaxTexture2DMipmappedWidth     = 73, 
    cudaDevAttrMaxTexture2DMipmappedHeight    = 74, 
    cudaDevAttrComputeCapabilityMajor         = 75,  
    cudaDevAttrComputeCapabilityMinor         = 76, 
    cudaDevAttrMaxTexture1DMipmappedWidth     = 77, 
    cudaDevAttrStreamPrioritiesSupported      = 78, 
    cudaDevAttrGlobalL1CacheSupported         = 79, 
    cudaDevAttrLocalL1CacheSupported          = 80, 
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81, 
    cudaDevAttrMaxRegistersPerMultiprocessor  = 82, 
    cudaDevAttrManagedMemory                  = 83, 
    cudaDevAttrIsMultiGpuBoard                = 84, 
    cudaDevAttrMultiGpuBoardGroupID           = 85  
};




struct __declspec(__device_builtin__) cudaDeviceProp
{
    char   name[256];                  
    size_t totalGlobalMem;             
    size_t sharedMemPerBlock;          
    int    regsPerBlock;               
    int    warpSize;                   
    size_t memPitch;                   
    int    maxThreadsPerBlock;         
    int    maxThreadsDim[3];           
    int    maxGridSize[3];             
    int    clockRate;                  
    size_t totalConstMem;              
    int    major;                      
    int    minor;                      
    size_t textureAlignment;           
    size_t texturePitchAlignment;      
    int    deviceOverlap;              
    int    multiProcessorCount;        
    int    kernelExecTimeoutEnabled;   
    int    integrated;                 
    int    canMapHostMemory;           
    int    computeMode;                
    int    maxTexture1D;               
    int    maxTexture1DMipmap;         
    int    maxTexture1DLinear;         
    int    maxTexture2D[2];            
    int    maxTexture2DMipmap[2];      
    int    maxTexture2DLinear[3];      
    int    maxTexture2DGather[2];      
    int    maxTexture3D[3];            
    int    maxTexture3DAlt[3];         
    int    maxTextureCubemap;          
    int    maxTexture1DLayered[2];     
    int    maxTexture2DLayered[3];     
    int    maxTextureCubemapLayered[2];
    int    maxSurface1D;               
    int    maxSurface2D[2];            
    int    maxSurface3D[3];            
    int    maxSurface1DLayered[2];     
    int    maxSurface2DLayered[3];     
    int    maxSurfaceCubemap;          
    int    maxSurfaceCubemapLayered[2];
    size_t surfaceAlignment;           
    int    concurrentKernels;          
    int    ECCEnabled;                 
    int    pciBusID;                   
    int    pciDeviceID;                
    int    pciDomainID;                
    int    tccDriver;                  
    int    asyncEngineCount;           
    int    unifiedAddressing;          
    int    memoryClockRate;            
    int    memoryBusWidth;             
    int    l2CacheSize;                
    int    maxThreadsPerMultiProcessor;
    int    streamPrioritiesSupported;  
    int    globalL1CacheSupported;     
    int    localL1CacheSupported;      
    size_t sharedMemPerMultiprocessor; 
    int    regsPerMultiprocessor;      
    int    managedMemory;              
    int    isMultiGpuBoard;            
    int    multiGpuBoardGroupID;       
};











































































typedef __declspec(__device_builtin__) struct __declspec(__device_builtin__) cudaIpcEventHandle_st
{
    char reserved[64];
}cudaIpcEventHandle_t;




typedef __declspec(__device_builtin__) struct __declspec(__device_builtin__) cudaIpcMemHandle_st 
{
    char reserved[64];
}cudaIpcMemHandle_t;










typedef __declspec(__device_builtin__) enum cudaError cudaError_t;




typedef __declspec(__device_builtin__) struct CUstream_st *cudaStream_t;




typedef __declspec(__device_builtin__) struct CUevent_st *cudaEvent_t;




typedef __declspec(__device_builtin__) struct cudaGraphicsResource *cudaGraphicsResource_t;




typedef __declspec(__device_builtin__) struct CUuuid_st cudaUUID_t;




typedef __declspec(__device_builtin__) enum cudaOutputMode cudaOutputMode_t;


 

#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
























enum __declspec(__device_builtin__) cudaSurfaceBoundaryMode
{
    cudaBoundaryModeZero  = 0,    
    cudaBoundaryModeClamp = 1,    
    cudaBoundaryModeTrap  = 2     
};




enum __declspec(__device_builtin__)  cudaSurfaceFormatMode
{
    cudaFormatModeForced = 0,     
    cudaFormatModeAuto = 1        
};




struct __declspec(__device_builtin__) surfaceReference
{
    


    struct cudaChannelFormatDesc channelDesc;
};




typedef __declspec(__device_builtin__) unsigned long long cudaSurfaceObject_t;


 

#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
























enum __declspec(__device_builtin__) cudaTextureAddressMode
{
    cudaAddressModeWrap   = 0,    
    cudaAddressModeClamp  = 1,    
    cudaAddressModeMirror = 2,    
    cudaAddressModeBorder = 3     
};




enum __declspec(__device_builtin__) cudaTextureFilterMode
{
    cudaFilterModePoint  = 0,     
    cudaFilterModeLinear = 1      
};




enum __declspec(__device_builtin__) cudaTextureReadMode
{
    cudaReadModeElementType     = 0,  
    cudaReadModeNormalizedFloat = 1   
};




struct __declspec(__device_builtin__) textureReference
{
    


    int                          normalized;
    


    enum cudaTextureFilterMode   filterMode;
    


    enum cudaTextureAddressMode  addressMode[3];
    


    struct cudaChannelFormatDesc channelDesc;
    


    int                          sRGB;
    


    unsigned int                 maxAnisotropy;
    


    enum cudaTextureFilterMode   mipmapFilterMode;
    


    float                        mipmapLevelBias;
    


    float                        minMipmapLevelClamp;
    


    float                        maxMipmapLevelClamp;
    int                          __cudaReserved[15];
};




struct __declspec(__device_builtin__) cudaTextureDesc
{
    


    enum cudaTextureAddressMode addressMode[3];
    


    enum cudaTextureFilterMode  filterMode;
    


    enum cudaTextureReadMode    readMode;
    


    int                         sRGB;
    


    int                         normalizedCoords;
    


    unsigned int                maxAnisotropy;
    


    enum cudaTextureFilterMode  mipmapFilterMode;
    


    float                       mipmapLevelBias;
    


    float                       minMipmapLevelClamp;
    


    float                       maxMipmapLevelClamp;
};




typedef __declspec(__device_builtin__) unsigned long long cudaTextureObject_t;


 

#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"



























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"






















#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"







#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"

struct __declspec(__device_builtin__) char1
{
    signed char x;
};

struct __declspec(__device_builtin__) uchar1
{
    unsigned char x;
};


struct __declspec(__device_builtin__) __declspec(align(2)) char2
{
    signed char x, y;
};

struct __declspec(__device_builtin__) __declspec(align(2)) uchar2
{
    unsigned char x, y;
};

struct __declspec(__device_builtin__) char3
{
    signed char x, y, z;
};

struct __declspec(__device_builtin__) uchar3
{
    unsigned char x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(4)) char4
{
    signed char x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(4)) uchar4
{
    unsigned char x, y, z, w;
};

struct __declspec(__device_builtin__) short1
{
    short x;
};

struct __declspec(__device_builtin__) ushort1
{
    unsigned short x;
};

struct __declspec(__device_builtin__) __declspec(align(4)) short2
{
    short x, y;
};

struct __declspec(__device_builtin__) __declspec(align(4)) ushort2
{
    unsigned short x, y;
};

struct __declspec(__device_builtin__) short3
{
    short x, y, z;
};

struct __declspec(__device_builtin__) ushort3
{
    unsigned short x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(8)) short4 { short x; short y; short z; short w; };
struct __declspec(__device_builtin__) __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

struct __declspec(__device_builtin__) int1
{
    int x;
};

struct __declspec(__device_builtin__) uint1
{
    unsigned int x;
};

struct __declspec(__device_builtin__) __declspec(align(8)) int2 { int x; int y; };
struct __declspec(__device_builtin__) __declspec(align(8)) uint2 { unsigned int x; unsigned int y; };

struct __declspec(__device_builtin__) int3
{
    int x, y, z;
};

struct __declspec(__device_builtin__) uint3
{
    unsigned int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) int4
{
    int x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) uint4
{
    unsigned int x, y, z, w;
};

struct __declspec(__device_builtin__) long1
{
    long int x;
};

struct __declspec(__device_builtin__) ulong1
{
    unsigned long x;
};


struct __declspec(__device_builtin__) __declspec(align(8)) long2 { long int x; long int y; };
struct __declspec(__device_builtin__) __declspec(align(8)) ulong2 { unsigned long int x; unsigned long int y; };












#line 229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"

struct __declspec(__device_builtin__) long3
{
    long int x, y, z;
};

struct __declspec(__device_builtin__) ulong3
{
    unsigned long int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) long4
{
    long int x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulong4
{
    unsigned long int x, y, z, w;
};

struct __declspec(__device_builtin__) float1
{
    float x;
};















#line 271 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"

struct __declspec(__device_builtin__) __declspec(align(8)) float2 { float x; float y; };

#line 275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"


struct __declspec(__device_builtin__) float3
{
    float x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) float4
{
    float x, y, z, w;
};

struct __declspec(__device_builtin__) longlong1
{
    long long int x;
};

struct __declspec(__device_builtin__) ulonglong1
{
    unsigned long long int x;
};

struct __declspec(__device_builtin__) __declspec(align(16)) longlong2
{
    long long int x, y;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulonglong2
{
    unsigned long long int x, y;
};

struct __declspec(__device_builtin__) longlong3
{
    long long int x, y, z;
};

struct __declspec(__device_builtin__) ulonglong3
{
    unsigned long long int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) longlong4
{
    long long int x, y, z ,w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulonglong4
{
    unsigned long long int x, y, z, w;
};

struct __declspec(__device_builtin__) double1
{
    double x;
};

struct __declspec(__device_builtin__) __declspec(align(16)) double2
{
    double x, y;
};

struct __declspec(__device_builtin__) double3
{
    double x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) double4
{
    double x, y, z, w;
};





#line 353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"







typedef __declspec(__device_builtin__) struct char1 char1;
typedef __declspec(__device_builtin__) struct uchar1 uchar1;
typedef __declspec(__device_builtin__) struct char2 char2;
typedef __declspec(__device_builtin__) struct uchar2 uchar2;
typedef __declspec(__device_builtin__) struct char3 char3;
typedef __declspec(__device_builtin__) struct uchar3 uchar3;
typedef __declspec(__device_builtin__) struct char4 char4;
typedef __declspec(__device_builtin__) struct uchar4 uchar4;
typedef __declspec(__device_builtin__) struct short1 short1;
typedef __declspec(__device_builtin__) struct ushort1 ushort1;
typedef __declspec(__device_builtin__) struct short2 short2;
typedef __declspec(__device_builtin__) struct ushort2 ushort2;
typedef __declspec(__device_builtin__) struct short3 short3;
typedef __declspec(__device_builtin__) struct ushort3 ushort3;
typedef __declspec(__device_builtin__) struct short4 short4;
typedef __declspec(__device_builtin__) struct ushort4 ushort4;
typedef __declspec(__device_builtin__) struct int1 int1;
typedef __declspec(__device_builtin__) struct uint1 uint1;
typedef __declspec(__device_builtin__) struct int2 int2;
typedef __declspec(__device_builtin__) struct uint2 uint2;
typedef __declspec(__device_builtin__) struct int3 int3;
typedef __declspec(__device_builtin__) struct uint3 uint3;
typedef __declspec(__device_builtin__) struct int4 int4;
typedef __declspec(__device_builtin__) struct uint4 uint4;
typedef __declspec(__device_builtin__) struct long1 long1;
typedef __declspec(__device_builtin__) struct ulong1 ulong1;
typedef __declspec(__device_builtin__) struct long2 long2;
typedef __declspec(__device_builtin__) struct ulong2 ulong2;
typedef __declspec(__device_builtin__) struct long3 long3;
typedef __declspec(__device_builtin__) struct ulong3 ulong3;
typedef __declspec(__device_builtin__) struct long4 long4;
typedef __declspec(__device_builtin__) struct ulong4 ulong4;
typedef __declspec(__device_builtin__) struct float1 float1;
typedef __declspec(__device_builtin__) struct float2 float2;
typedef __declspec(__device_builtin__) struct float3 float3;
typedef __declspec(__device_builtin__) struct float4 float4;
typedef __declspec(__device_builtin__) struct longlong1 longlong1;
typedef __declspec(__device_builtin__) struct ulonglong1 ulonglong1;
typedef __declspec(__device_builtin__) struct longlong2 longlong2;
typedef __declspec(__device_builtin__) struct ulonglong2 ulonglong2;
typedef __declspec(__device_builtin__) struct longlong3 longlong3;
typedef __declspec(__device_builtin__) struct ulonglong3 ulonglong3;
typedef __declspec(__device_builtin__) struct longlong4 longlong4;
typedef __declspec(__device_builtin__) struct ulonglong4 ulonglong4;
typedef __declspec(__device_builtin__) struct double1 double1;
typedef __declspec(__device_builtin__) struct double2 double2;
typedef __declspec(__device_builtin__) struct double3 double3;
typedef __declspec(__device_builtin__) struct double4 double4;







struct __declspec(__device_builtin__) dim3
{
    unsigned int x, y, z;

    __declspec(__host__) __declspec(__device__) dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __declspec(__host__) __declspec(__device__) dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __declspec(__host__) __declspec(__device__) operator uint3(void) { uint3 t; t.x = x; t.y = y; t.z = z; return t; }
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
};

typedef __declspec(__device_builtin__) struct dim3 dim3;



#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"













































































































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_device_runtime_api.h"


























































































#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_device_runtime_api.h"

















































#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_device_runtime_api.h"
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_device_runtime_api.h"

#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_device_runtime_api.h"

#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_device_runtime_api.h"
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"













#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"

#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"






#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"



#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"


extern "C" {
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceReset(void);
















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceSynchronize(void);




















































































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetLimit(enum cudaLimit limit, size_t value);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);






























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);


































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int *leastPriority, int *greatestPriority);









































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetCacheConfig(enum cudaFuncCache cacheConfig);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);









































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig config);






















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetByPCIBusId(int *device, const char *pciBusId);


























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);









































extern __declspec(__host__) cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle, cudaEvent_t event);


































extern __declspec(__host__) cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t *event, cudaIpcEventHandle_t handle);





































extern __declspec(__host__) cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle, void *devPtr);

















































extern __declspec(__host__) cudaError_t __stdcall cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned int flags);





























extern __declspec(__host__) cudaError_t __stdcall cudaIpcCloseMemHandle(void *devPtr);

 





































extern __declspec(__host__) cudaError_t __stdcall cudaThreadExit(void);























extern __declspec(__host__) cudaError_t __stdcall cudaThreadSynchronize(void);


























































extern __declspec(__host__) cudaError_t __stdcall cudaThreadSetLimit(enum cudaLimit limit, size_t value);






























extern __declspec(__host__) cudaError_t __stdcall cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);


































extern __declspec(__host__) cudaError_t __stdcall cudaThreadGetCacheConfig(enum cudaFuncCache *pCacheConfig);













































extern __declspec(__host__) cudaError_t __stdcall cudaThreadSetCacheConfig(enum cudaFuncCache cacheConfig);

 



















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetLastError(void);








































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaPeekAtLastError(void);














extern __declspec(__host__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorName(cudaError_t error);














extern __declspec(__host__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorString(cudaError_t error);
 




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceCount(int *count);











































































































































































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);































































































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);


















extern __declspec(__host__) cudaError_t __stdcall cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);

































extern __declspec(__host__) cudaError_t __stdcall cudaSetDevice(int device);
















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDevice(int *device);




























extern __declspec(__host__) cudaError_t __stdcall cudaSetValidDevices(int *device_arr, int len);



























































extern __declspec(__host__) cudaError_t __stdcall cudaSetDeviceFlags( unsigned int flags );

 



































extern __declspec(__host__) cudaError_t __stdcall cudaStreamCreate(cudaStream_t *pStream);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);










































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t *pStream, unsigned int flags, int priority);























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int *priority);




















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned int *flags);




















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);





#line 1922 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"







typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void *userData);





























































extern __declspec(__host__) cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream,
        cudaStreamCallback_t callback, void *userData, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream);




















extern __declspec(__host__) cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream);

































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void *devPtr, size_t length, unsigned int flags);

 

































extern __declspec(__host__) cudaError_t __stdcall cudaEventCreate(cudaEvent_t *event);

































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);






























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);































extern __declspec(__host__) cudaError_t __stdcall cudaEventQuery(cudaEvent_t event);































extern __declspec(__host__) cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event);
























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);








































extern __declspec(__host__) cudaError_t __stdcall cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);

 












































extern __declspec(__host__) cudaError_t __stdcall cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0);


























extern __declspec(__host__) cudaError_t __stdcall cudaSetupArgument(const void *arg, size_t size, size_t offset);














































extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetCacheConfig(const void *func, enum cudaFuncCache cacheConfig);


















































extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void *func, enum cudaSharedMemConfig config);


































extern __declspec(__host__) cudaError_t __stdcall cudaLaunch(const void *func);
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);





















extern __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForDevice(double *d);





















extern __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForHost(double *d);

 


















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize);

 
#line 2670 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"




















































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMallocManaged(void **devPtr, size_t size, unsigned int flags);






















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);




























extern __declspec(__host__) cudaError_t __stdcall cudaMallocHost(void **ptr, size_t size);






































extern __declspec(__host__) cudaError_t __stdcall cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);









































extern __declspec(__host__) cudaError_t __stdcall cudaMallocArray(cudaArray_t *array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFree(void *devPtr);



















extern __declspec(__host__) cudaError_t __stdcall cudaFreeHost(void *ptr);





















extern __declspec(__host__) cudaError_t __stdcall cudaFreeArray(cudaArray_t array);





















extern __declspec(__host__) cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);


























































extern __declspec(__host__) cudaError_t __stdcall cudaHostAlloc(void **pHost, size_t size, unsigned int flags);




















































extern __declspec(__host__) cudaError_t __stdcall cudaHostRegister(void *ptr, size_t size, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaHostUnregister(void *ptr);


























extern __declspec(__host__) cudaError_t __stdcall cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaHostGetFlags(unsigned int *pFlags, void *pHost);


































extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);






































































































































extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t *array, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
























































































































extern __declspec(__host__) cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int numLevels, unsigned int flags = 0);

























extern __declspec(__host__) cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t *levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned int level);
































































































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3D(const struct cudaMemcpy3DParms *p);



























extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms *p);








































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);






















extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms *p, cudaStream_t stream = 0);


















extern __declspec(__host__) cudaError_t __stdcall cudaMemGetInfo(size_t *free, size_t *total);




















extern __declspec(__host__) cudaError_t __stdcall cudaArrayGetInfo(struct cudaChannelFormatDesc *desc, struct cudaExtent *extent, unsigned int *flags, cudaArray_t array);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyPeer(void *dst, int dstDevice, const void *src, int srcDevice, size_t count);

































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);

































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArray(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);







































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);










































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyPeerAsync(void *dst, int dstDevice, const void *src, int srcDevice, size_t count, cudaStream_t stream = 0);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);



















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);


















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);










































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);










































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void *dst, const void *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

























extern __declspec(__host__) cudaError_t __stdcall cudaMemset(void *devPtr, int value, size_t count);





























extern __declspec(__host__) cudaError_t __stdcall cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);










































extern __declspec(__host__) cudaError_t __stdcall cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream = 0);

































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0);














































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream = 0);






















extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolAddress(void **devPtr, const void *symbol);





















extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolSize(size_t *size, const void *symbol);

 























































































































































extern __declspec(__host__) cudaError_t __stdcall cudaPointerGetAttributes(struct cudaPointerAttributes *attributes, const void *ptr);

 



































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceCanAccessPeer(int *canAccessPeer, int device, int peerDevice);




































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice);

 























































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned int flags);



































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);




























extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, cudaGraphicsResource_t resource);

































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array, cudaGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel);
























extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);

 





































extern __declspec(__host__) cudaError_t __stdcall cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, cudaArray_const_t array);


































extern __declspec(__host__) struct cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);














































extern __declspec(__host__) cudaError_t __stdcall cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = 0xffffffff);


















































extern __declspec(__host__) cudaError_t __stdcall cudaBindTexture2D(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t width, size_t height, size_t pitch);



























extern __declspec(__host__) cudaError_t __stdcall cudaBindTextureToArray(const struct textureReference *texref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);



























extern __declspec(__host__) cudaError_t __stdcall cudaBindTextureToMipmappedArray(const struct textureReference *texref, cudaMipmappedArray_const_t mipmappedArray, const struct cudaChannelFormatDesc *desc);




















extern __declspec(__host__) cudaError_t __stdcall cudaUnbindTexture(const struct textureReference *texref);
























extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
























extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureReference(const struct textureReference **texref, const void *symbol);

 





































extern __declspec(__host__) cudaError_t __stdcall cudaBindSurfaceToArray(const struct surfaceReference *surfref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);


















extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceReference(const struct surfaceReference **surfref, const void *symbol);

 




















































































































































































































extern __declspec(__host__) cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);














extern __declspec(__host__) cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject);















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaTextureObject_t texObject);















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectTextureDesc(struct cudaTextureDesc *pTexDesc, cudaTextureObject_t texObject);
















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc *pResViewDesc, cudaTextureObject_t texObject);

 


































extern __declspec(__host__) cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject, const struct cudaResourceDesc *pResDesc);














extern __declspec(__host__) cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);














extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaSurfaceObject_t surfObject);

 
























extern __declspec(__host__) cudaError_t __stdcall cudaDriverGetVersion(int *driverVersion);
















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);

 


extern __declspec(__host__) cudaError_t __stdcall cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);







































































































































}

#line 6207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"



#line 6211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"

#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"










































template<class T> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;



#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}



template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned long>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long1>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong1>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long2>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong2>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long4>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong4>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

#line 408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"


 

#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
#line 69 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 6211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_runtime_api.h"

#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_functions.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 55 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 56 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_functions.h"























static __inline __declspec(__host__) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
{
  struct cudaPitchedPtr s;

  s.ptr   = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}
















static __inline __declspec(__host__) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}
















static __inline __declspec(__host__) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
{
  struct cudaExtent e;

  e.width  = w;
  e.height = h;
  e.depth  = d;

  return e;
}

 

#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_functions.h"
#line 71 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 72 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"







static __inline __declspec(__host__) __declspec(__device__) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short3 make_short3(short x,short y, short z)
{ 
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 73 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"



#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"


extern "C" {
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"




#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
















__declspec(dllimport) void *  __cdecl _memccpy(   void * _Dst,   const void * _Src,   int _Val,   size_t _MaxCount);
 __declspec(dllimport) const void *  __cdecl memchr(    const void * _Buf ,   int _Val,   size_t _MaxCount);
 __declspec(dllimport) int     __cdecl _memicmp(   const void * _Buf1,    const void * _Buf2,   size_t _Size);
 __declspec(dllimport) int     __cdecl _memicmp_l(   const void * _Buf1,    const void * _Buf2,   size_t _Size,    _locale_t _Locale);
         int     __cdecl memcmp(   const void * _Buf1,    const void * _Buf2,   size_t _Size);
         void *  __cdecl memcpy(    void * _Dst,    const void * _Src,   size_t _Size);

__declspec(dllimport) errno_t  __cdecl memcpy_s(    void * _Dst,   rsize_t _DstSize,    const void * _Src,   rsize_t _MaxCount);





















#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"










#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
        void *  __cdecl memset(    void * _Dst,   int _Val,   size_t _Size);



 __declspec(dllimport) void * __cdecl memccpy(  void * _Dst,    const void * _Src,   int _Val,   size_t _Size);
  __declspec(dllimport) int __cdecl memicmp(   const void * _Buf1,    const void * _Buf2,   size_t _Size);
#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl _strset_s(    char * _Dst,   size_t _DstSize,   int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(    char (&_Dest)[_Size],   int _Value) throw() { return _strset_s(_Dest, _Size, _Value); } }
  char * __cdecl _strset(  char *_Dest,  int _Value);

 __declspec(dllimport) errno_t __cdecl strcpy_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src);
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Dest)[_Size],    const char * _Source) throw() { return strcpy_s(_Dest, _Size, _Source); } }
  char * __cdecl strcpy(  char *_Dest,  const char * _Source);

 __declspec(dllimport) errno_t __cdecl strcat_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src);
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(    char (&_Dest)[_Size],    const char * _Source) throw() { return strcat_s(_Dest, _Size, _Source); } }
  char * __cdecl strcat(  char *_Dest,  const char * _Source);
         int     __cdecl strcmp(   const char * _Str1,    const char * _Str2);
         size_t  __cdecl strlen(   const char * _Str);
 __declspec(dllimport) size_t  __cdecl strnlen(   const char * _Str,   size_t _MaxCount);

 static __inline size_t  __cdecl strnlen_s(    const char * _Str,   size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl memmove_s(    void * _Dst,   rsize_t _DstSize,    const void * _Src,   rsize_t _MaxCount);
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"



#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
__declspec(dllimport)  void *  __cdecl memmove(    void * _Dst,    const void * _Src,   size_t _Size);
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"




#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

 __declspec(dllimport) char *  __cdecl _strdup(   const char * _Src);



#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

 __declspec(dllimport) const char *  __cdecl strchr(   const char * _Str,   int _Val);
 __declspec(dllimport) int     __cdecl _stricmp(    const char * _Str1,     const char * _Str2);
 __declspec(dllimport) int     __cdecl _strcmpi(    const char * _Str1,     const char * _Str2);
 __declspec(dllimport) int     __cdecl _stricmp_l(    const char * _Str1,     const char * _Str2,    _locale_t _Locale);
 __declspec(dllimport) int     __cdecl strcoll(    const char * _Str1,     const  char * _Str2);
 __declspec(dllimport) int     __cdecl _strcoll_l(    const char * _Str1,     const char * _Str2,    _locale_t _Locale);
 __declspec(dllimport) int     __cdecl _stricoll(    const char * _Str1,     const char * _Str2);
 __declspec(dllimport) int     __cdecl _stricoll_l(    const char * _Str1,     const char * _Str2,    _locale_t _Locale);
 __declspec(dllimport) int     __cdecl _strncoll  (   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
 __declspec(dllimport) int     __cdecl _strncoll_l(   const char * _Str1,    const char * _Str2,   size_t _MaxCount,    _locale_t _Locale);
 __declspec(dllimport) int     __cdecl _strnicoll (   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
 __declspec(dllimport) int     __cdecl _strnicoll_l(   const char * _Str1,    const char * _Str2,   size_t _MaxCount,    _locale_t _Locale);
 __declspec(dllimport) size_t  __cdecl strcspn(    const char * _Str,     const char * _Control);
  __declspec(dllimport) char *  __cdecl _strerror(   const char * _ErrMsg);
 __declspec(dllimport) errno_t __cdecl _strerror_s(    char * _Buf,   size_t _SizeInBytes,    const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],    const char * _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
  __declspec(dllimport) char *  __cdecl strerror(  int);

 __declspec(dllimport) errno_t __cdecl strerror_s(    char * _Buf,   size_t _SizeInBytes,   int _ErrNum);
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
 __declspec(dllimport) errno_t __cdecl _strlwr_s(    char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(    char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
 __declspec(dllimport) char * __cdecl _strlwr(  char *_String);
 __declspec(dllimport) errno_t __cdecl _strlwr_s_l(    char * _Str,   size_t _Size,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(    char (&_String)[_Size],    _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) char * __cdecl _strlwr_l(    char *_String,    _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncat_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src,   rsize_t _MaxCount);
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(    char (&_Dest)[_Size],    const char * _Source,   size_t _Count) throw() { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)

 __declspec(dllimport) char * __cdecl strncat(    char *_Dest,    const char * _Source,   size_t _Count);
#pragma warning(pop)


#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
 __declspec(dllimport) int     __cdecl strncmp(   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
 __declspec(dllimport) int     __cdecl _strnicmp(   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
 __declspec(dllimport) int     __cdecl _strnicmp_l(   const char * _Str1,    const char * _Str2,   size_t _MaxCount,    _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncpy_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src,   rsize_t _MaxCount);
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size],    const char * _Source,   size_t _Count) throw() { return strncpy_s(_Dest, _Size, _Source, _Count); } }
 __declspec(dllimport) char * __cdecl strncpy(   char *_Dest,    const char * _Source,   size_t _Count);
 __declspec(dllimport) errno_t __cdecl _strnset_s(    char * _Str,   size_t _SizeInBytes,   int _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(    char (&_Dest)[_Size],   int _Val,   size_t _Count) throw() { return _strnset_s(_Dest, _Size, _Val, _Count); } }
 __declspec(dllimport) char * __cdecl _strnset(    char *_Dest,   int _Val,   size_t _Count);
 __declspec(dllimport) const char *  __cdecl strpbrk(   const char * _Str,    const char * _Control);
 __declspec(dllimport) const char *  __cdecl strrchr(   const char * _Str,   int _Ch);
__declspec(dllimport) char *  __cdecl _strrev(    char * _Str);
 __declspec(dllimport) size_t  __cdecl strspn(   const char * _Str,    const char * _Control);
 __declspec(dllimport) const char *  __cdecl strstr(   const char * _Str,    const char * _SubStr);
  __declspec(dllimport) char *  __cdecl strtok(    char * _Str,    const char * _Delim);

 __declspec(dllimport) char *  __cdecl strtok_s(    char * _Str,    const char * _Delim,        char ** _Context);
#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
 __declspec(dllimport) errno_t __cdecl _strupr_s(    char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(    char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
 __declspec(dllimport) char * __cdecl _strupr(  char *_String);
 __declspec(dllimport) errno_t __cdecl _strupr_s_l(    char * _Str,   size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(    char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) char * __cdecl _strupr_l(    char *_String,    _locale_t _Locale);
 __declspec(dllimport) size_t  __cdecl strxfrm (   char * _Dst,    const char * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t  __cdecl _strxfrm_l(   char * _Dst,    const char * _Src,   size_t _MaxCount,    _locale_t _Locale);


extern "C++" {


 inline char * __cdecl strchr(   char * _Str,   int _Ch)
	{ return (char*)strchr((const char*)_Str, _Ch); }
 inline char * __cdecl strpbrk(   char * _Str,    const char * _Control)
	{ return (char*)strpbrk((const char*)_Str, _Control); }
 inline char * __cdecl strrchr(   char * _Str,   int _Ch)
	{ return (char*)strrchr((const char*)_Str, _Ch); }
 inline char * __cdecl strstr(   char * _Str,    const char * _SubStr)
	{ return (char*)strstr((const char*)_Str, _SubStr); }
#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"


 inline void * __cdecl memchr(   void * _Pv,   int _C,   size_t _N)
	{ return (void*)memchr((const void*)_Pv, _C, _N); }
#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
}
#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"






#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

  __declspec(dllimport) char * __cdecl strdup(   const char * _Src);



#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"


  __declspec(dllimport) int __cdecl strcmpi(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int __cdecl stricmp(   const char * _Str1,    const char * _Str2);
 __declspec(dllimport) char * __cdecl strlwr(    char * _Str);
  __declspec(dllimport) int __cdecl strnicmp(   const char * _Str1,    const char * _Str,   size_t _MaxCount);
 __declspec(dllimport) char * __cdecl strnset(    char * _Str,   int _Val,   size_t _MaxCount);
 __declspec(dllimport) char * __cdecl strrev(    char * _Str);
         char * __cdecl strset(    char * _Str,   int _Val);
 __declspec(dllimport) char * __cdecl strupr(    char * _Str);

#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"









#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

 __declspec(dllimport) wchar_t * __cdecl _wcsdup(   const wchar_t * _Str);



#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"


 __declspec(dllimport) errno_t __cdecl wcscat_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src);
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(    wchar_t (&_Dest)[_Size],    const wchar_t * _Source) throw() { return wcscat_s(_Dest, _Size, _Source); } }
 __declspec(dllimport) wchar_t * __cdecl wcscat(  wchar_t *_Dest,  const wchar_t * _Source);
 __declspec(dllimport) const wchar_t * __cdecl wcschr(   const wchar_t * _Str, wchar_t _Ch);
 __declspec(dllimport) int __cdecl wcscmp(   const wchar_t * _Str1,    const wchar_t * _Str2);

 __declspec(dllimport) errno_t __cdecl wcscpy_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src);
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Dest)[_Size],    const wchar_t * _Source) throw() { return wcscpy_s(_Dest, _Size, _Source); } }
 __declspec(dllimport) wchar_t * __cdecl wcscpy(  wchar_t *_Dest,  const wchar_t * _Source);
 __declspec(dllimport) size_t __cdecl wcscspn(   const wchar_t * _Str,    const wchar_t * _Control);
 __declspec(dllimport) size_t __cdecl wcslen(   const wchar_t * _Str);
 __declspec(dllimport) size_t __cdecl wcsnlen(   const wchar_t * _Src,   size_t _MaxCount);

 static __inline size_t __cdecl wcsnlen_s(   const wchar_t * _Src,   size_t _MaxCount)
{
    return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}
#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl wcsncat_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src,   rsize_t _MaxCount);
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(    wchar_t (&_Dest)[_Size],    const wchar_t * _Source,   size_t _Count) throw() { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
 __declspec(dllimport) wchar_t * __cdecl wcsncat(    wchar_t *_Dest,    const wchar_t * _Source,   size_t _Count);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl wcsncmp(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl wcsncpy_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src,   rsize_t _MaxCount);
#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size],    const wchar_t * _Source,   size_t _Count) throw() { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
 __declspec(dllimport) wchar_t * __cdecl wcsncpy(   wchar_t *_Dest,    const wchar_t * _Source,   size_t _Count);
 __declspec(dllimport) const wchar_t * __cdecl wcspbrk(   const wchar_t * _Str,    const wchar_t * _Control);
 __declspec(dllimport) const wchar_t * __cdecl wcsrchr(   const wchar_t * _Str,   wchar_t _Ch);
 __declspec(dllimport) size_t __cdecl wcsspn(   const wchar_t * _Str,    const wchar_t * _Control);
 __declspec(dllimport) const wchar_t * __cdecl wcsstr(   const wchar_t * _Str,    const wchar_t * _SubStr);
  __declspec(dllimport) wchar_t * __cdecl wcstok(    wchar_t * _Str,    const wchar_t * _Delim);

 __declspec(dllimport) wchar_t * __cdecl wcstok_s(    wchar_t * _Str,    const wchar_t * _Delim,        wchar_t ** _Context);
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
  __declspec(dllimport) wchar_t * __cdecl _wcserror(  int _ErrNum);
 __declspec(dllimport) errno_t __cdecl _wcserror_s(    wchar_t * _Buf,   size_t _SizeInWords,   int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
  __declspec(dllimport) wchar_t * __cdecl __wcserror(   const wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl __wcserror_s(    wchar_t * _Buffer,   size_t _SizeInWords,    const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],    const wchar_t * _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

 __declspec(dllimport) int __cdecl _wcsicmp(   const wchar_t * _Str1,    const wchar_t * _Str2);
 __declspec(dllimport) int __cdecl _wcsicmp_l(   const wchar_t * _Str1,    const wchar_t * _Str2,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _wcsnicmp(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
 __declspec(dllimport) int __cdecl _wcsnicmp_l(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount,    _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsnset_s(    wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(    wchar_t (&_Dst)[_Size], wchar_t _Val,   size_t _MaxCount) throw() { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsnset(    wchar_t *_Str, wchar_t _Val,   size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(    wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl _wcsset_s(    wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(    wchar_t (&_Str)[_Size], wchar_t _Val) throw() { return _wcsset_s(_Str, _Size, _Val); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsset(    wchar_t *_Str, wchar_t _Val);

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(    wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(    wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wcslwr(  wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(    wchar_t * _Str,   size_t _SizeInWords,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(    wchar_t (&_String)[_Size],    _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) wchar_t * __cdecl _wcslwr_l(    wchar_t *_String,    _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s(    wchar_t * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(    wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsupr(  wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(    wchar_t * _Str,   size_t _Size,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(    wchar_t (&_String)[_Size],    _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsupr_l(    wchar_t *_String,    _locale_t _Locale);
 __declspec(dllimport) size_t __cdecl wcsxfrm(   wchar_t * _Dst,    const wchar_t * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t __cdecl _wcsxfrm_l(   wchar_t * _Dst,    const wchar_t *_Src,   size_t _MaxCount,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl wcscoll(   const wchar_t * _Str1,    const wchar_t * _Str2);
 __declspec(dllimport) int __cdecl _wcscoll_l(   const wchar_t * _Str1,    const wchar_t * _Str2,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _wcsicoll(   const wchar_t * _Str1,    const wchar_t * _Str2);
 __declspec(dllimport) int __cdecl _wcsicoll_l(   const wchar_t * _Str1,    const wchar_t *_Str2,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _wcsncoll(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
 __declspec(dllimport) int __cdecl _wcsncoll_l(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _wcsnicoll(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
 __declspec(dllimport) int __cdecl _wcsnicoll_l(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount,    _locale_t _Locale);




extern "C++" {
 inline wchar_t * __cdecl wcschr(   wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
 inline wchar_t * __cdecl wcspbrk(   wchar_t *_Str,    const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
 inline wchar_t * __cdecl wcsrchr(   wchar_t *_Str,   wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
 inline wchar_t * __cdecl wcsstr(   wchar_t *_Str,    const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 371 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"






#line 379 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

  __declspec(dllimport) wchar_t * __cdecl wcsdup(   const wchar_t * _Str);



#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"





  __declspec(dllimport) int __cdecl wcsicmp(   const wchar_t * _Str1,    const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl wcsnicmp(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
 __declspec(dllimport) wchar_t * __cdecl wcsnset(    wchar_t * _Str,   wchar_t _Val,   size_t _MaxCount);
 __declspec(dllimport) wchar_t * __cdecl wcsrev(    wchar_t * _Str);
 __declspec(dllimport) wchar_t * __cdecl wcsset(    wchar_t * _Str, wchar_t _Val);
 __declspec(dllimport) wchar_t * __cdecl wcslwr(    wchar_t * _Str);
 __declspec(dllimport) wchar_t * __cdecl wcsupr(    wchar_t * _Str);
  __declspec(dllimport) int __cdecl wcsicoll(   const wchar_t * _Str1,    const wchar_t * _Str2);

#line 400 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"


#line 403 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"



}
#line 408 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"

#line 410 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"



#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"






#pragma pack(push,8)


extern "C" {
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"








#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"




































typedef long clock_t;

#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"





















struct tm {
        int tm_sec;     
        int tm_min;     
        int tm_hour;    
        int tm_mday;    
        int tm_mon;     
        int tm_year;    
        int tm_wday;    
        int tm_yday;    
        int tm_isdst;   
        };

#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"












  __declspec(dllimport) int* __cdecl __daylight(void);



  __declspec(dllimport) long* __cdecl __dstbias(void);



  __declspec(dllimport) long* __cdecl __timezone(void);



   __declspec(dllimport) char ** __cdecl __tzname(void);


__declspec(dllimport) errno_t __cdecl _get_daylight(  int * _Daylight);
__declspec(dllimport) errno_t __cdecl _get_dstbias(  long * _Daylight_savings_bias);
__declspec(dllimport) errno_t __cdecl _get_timezone(  long * _Timezone);
__declspec(dllimport) errno_t __cdecl _get_tzname(  size_t *_ReturnValue,     char *_Buffer,   size_t _SizeInBytes,   int _Index);



  __declspec(dllimport) char * __cdecl asctime(  const struct tm * _Tm);

 __declspec(dllimport) errno_t __cdecl asctime_s(    char *_Buf,   size_t _SizeInBytes,   const struct tm * _Tm);
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   const struct tm * _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) char * __cdecl _ctime32(  const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _ctime32_s(    char *_Buf,   size_t _SizeInBytes,   const __time32_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   const __time32_t * _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) clock_t __cdecl clock(void);
__declspec(dllimport) double __cdecl _difftime32(  __time32_t _Time1,   __time32_t _Time2);

  __declspec(dllimport) struct tm * __cdecl _gmtime32(  const __time32_t * _Time);
 __declspec(dllimport) errno_t __cdecl _gmtime32_s(  struct tm *_Tm,   const __time32_t * _Time);

 __declspec(dllimport) struct tm * __cdecl _localtime32(  const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _localtime32_s(  struct tm *_Tm,   const __time32_t * _Time);

__declspec(dllimport) size_t __cdecl strftime(    char * _Buf,   size_t _SizeInBytes,     const char * _Format,   const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _strftime_l(   char *_Buf,   size_t _Max_size,     const char * _Format,   const struct tm *_Tm,    _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl _strdate_s(    char *_Buf,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
 __declspec(dllimport) char * __cdecl _strdate(  char *_Buffer);

 __declspec(dllimport) errno_t __cdecl _strtime_s(    char *_Buf ,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
 __declspec(dllimport) char * __cdecl _strtime(  char *_Buffer);

__declspec(dllimport) __time32_t __cdecl _time32(  __time32_t * _Time);
__declspec(dllimport) __time32_t __cdecl _mktime32(   struct tm * _Tm);
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(   struct tm * _Tm);




__declspec(dllimport) void __cdecl _tzset(void);
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"

 __declspec(dllimport) double __cdecl _difftime64(  __time64_t _Time1,   __time64_t _Time2);
 __declspec(dllimport) char * __cdecl _ctime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _ctime64_s(    char *_Buf,   size_t _SizeInBytes,   const __time64_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size],   const __time64_t * _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) struct tm * __cdecl _gmtime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _gmtime64_s(  struct tm *_Tm,   const __time64_t *_Time);

 __declspec(dllimport) struct tm * __cdecl _localtime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _localtime64_s(  struct tm *_Tm,   const __time64_t *_Time);

__declspec(dllimport) __time64_t __cdecl _mktime64(   struct tm * _Tm);
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(   struct tm * _Tm);
__declspec(dllimport) __time64_t __cdecl _time64(  __time64_t * _Time);


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetLocalTime" " instead. See online help for details.")) unsigned __cdecl _getsystime(  struct tm * _Tm);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetLocalTime" " instead. See online help for details.")) unsigned __cdecl _setsystime(  struct tm * _Tm, unsigned _MilliSec);










 
 __declspec(dllimport) wchar_t * __cdecl _wasctime(  const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s(    wchar_t *_Buf,   size_t _SizeInWords,   const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   const struct tm * _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) wchar_t * __cdecl _wctime32(  const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   const __time32_t * _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }

__declspec(dllimport) size_t __cdecl wcsftime(    wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t * _Format,    const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l(    wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t *_Format,   const struct tm *_Tm,    _locale_t _Locale);

__declspec(dllimport) errno_t __cdecl _wstrdate_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wstrdate(  wchar_t *_Buffer);

__declspec(dllimport) errno_t __cdecl _wstrtime_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wstrtime(  wchar_t *_Buffer);

 __declspec(dllimport) wchar_t * __cdecl _wctime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   const __time64_t * _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"












#pragma once







#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"





#pragma warning(push)
#pragma warning(disable:4996)















static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"

#pragma warning(pop)

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"


#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"












#pragma once







#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"




























































static __inline double __cdecl difftime(time_t _Time1, time_t _Time2)
{
    return _difftime64(_Time1,_Time2);
}
 static __inline char * __cdecl ctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _ctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t * _Time)
{
    return _ctime64_s(_Buffer, _SizeInBytes, _Time);
}
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
 static __inline struct tm * __cdecl gmtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _gmtime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl gmtime_s(struct tm * _Tm, const time_t * _Time)
{
    return _gmtime64_s(_Tm, _Time);
}
#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
 static __inline struct tm * __cdecl localtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _localtime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl localtime_s(struct tm * _Tm, const time_t * _Time)
{
    return _localtime64_s(_Tm, _Time);
}
static __inline time_t __cdecl mktime(struct tm * _Tm)
{
    return _mktime64(_Tm);
}
static __inline time_t __cdecl _mkgmtime(struct tm * _Tm)
{
    return _mkgmtime64(_Tm);
}
static __inline time_t __cdecl time(time_t * _Time)
{
    return _time64(_Time);
}
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"


#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"













 __declspec(dllimport) extern int daylight;
 __declspec(dllimport) extern long timezone;
 __declspec(dllimport) extern char * tzname[2];
#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"

 __declspec(dllimport) void __cdecl tzset(void);

#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"



}
#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"

#pragma pack(pop)

#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

extern "C"
{
extern __declspec(dllimport) __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) clock_t __cdecl clock(void) ;
extern         __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void*   __cdecl memset(void*, int, size_t) ;
extern         __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void*   __cdecl memcpy(void*, const void*, size_t) ;
}




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#pragma pack(push,8)









 
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"









































#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

		





#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

		


		




		

 
  

 

#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 
  
 #line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 
  
 #line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"













































	
	






		
			
		

#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

	
	




		
			
		

#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

	
	
		
	



#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"




#line 191 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


	
		#pragma detect_mismatch("_MSC_VER", "1600")
	#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

	
		

#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
		     #pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
		

#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"





#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"




#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"



#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"











#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"



 
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 












#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 
 

 #line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 









 









 









 

 









 









 




 





 













#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"











#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"













#pragma once












#pragma comment(lib,"msvcprtd")


#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"

















#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"

#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"

#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"

#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"
#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"







#line 366 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"







#line 374 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 











 
  

#line 392 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
   
  #line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"






 










 
  

#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
   
  #line 418 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 419 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 
  

#line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
   
  #line 426 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 

   


#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
    
   #line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 #line 439 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 
  

#line 445 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
   
  #line 447 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 448 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 
  

#line 454 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
   
  #line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 457 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


 
  

#line 463 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
   
  #line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 
  
 #line 470 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 
   


     
   #line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 #line 478 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"


    
#line 482 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"



		

 
  
  
  




  
  
  

  







   
   
   
  #line 511 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

  
  
  
  

 












#line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 

 
namespace std {
typedef bool _Bool;
}
 #line 539 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		


 
  
 #line 562 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"






 
#line 570 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

		
 
#line 574 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
 
  
typedef unsigned short char16_t;
typedef unsigned int char32_t;
 #line 579 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

 #line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 624 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit();	
  #line 628 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit *);
    static  void __cdecl _Lockit_ctor(_Lockit *, int);
    static  void __cdecl _Lockit_dtor(_Lockit *);

	 _Lockit(const _Lockit&);				
	_Lockit&  operator=(const _Lockit&);	

	int _Locktype;

  











#line 655 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 741 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

class __declspec(dllimport) _Mutex
	{	
public:

 
  
























#line 773 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
    __thiscall _Mutex(_Uninitialized)
		{	
		}

    __thiscall _Mutex();
	__thiscall ~_Mutex();
	void __thiscall _Lock();
	void __thiscall _Unlock();
  #line 782 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Mutex_ctor(_Mutex *);
    static  void __cdecl _Mutex_dtor(_Mutex *);
    static  void __cdecl _Mutex_Lock(_Mutex *);
    static  void __cdecl _Mutex_Unlock(_Mutex *);

	 _Mutex(const _Mutex&);				
	_Mutex&  operator=(const _Mutex&);	
	void *_Mtx;

  







#line 802 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	};

class __declspec(dllimport) _Init_locks
	{	
public:
 
      










#line 820 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
    __thiscall _Init_locks();
	__thiscall ~_Init_locks();
  #line 823 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks *);
    static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 837 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 842 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;
typedef unsigned long _Uint32t;





 

 #pragma pack(pop)

#line 863 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"






#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

 
  
  
  
 #line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstddef"

#pragma once










 
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstddef"

#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstddef"





#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

 #pragma pack(push,8)
 #pragma warning(push,3)

namespace std {
		
 

 
 
 
 
 

 
 

 



  
  

   
   

 
























#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

		


		
 
 

		

template<bool _Test,
	class _Ty1,
	class _Ty2>
	class _If
	{	
public:
	typedef _Ty2 _Type;
	};

template<class _Ty1,
	class _Ty2>
	class _If<true, _Ty1, _Ty2>
	{	
public:
	typedef _Ty1 _Type;
	};

 
  

	namespace tr1 {
typedef char (&_No)[1];
typedef char (&_Yes)[2];
	}	
 #line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

 

  

struct _Bool_struct
	{	
	int _Member;
	};

  









   

typedef int _Bool_struct::* _Bool_type;
  #line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

 #line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"

		
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
}


 #pragma warning(pop)
 #pragma pack(pop)

#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"





#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

 #pragma pack(push,8)
 #pragma warning(push,3)










namespace std {

  


  



  



}

 

 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"











#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"








#pragma pack(push,8)







typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();





#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"








struct _EXCEPTION_POINTERS;

typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"

__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) void __cdecl unexpected(void);

__declspec(dllimport) int __cdecl _is_exception_typeof(  const type_info &_Type,   struct _EXCEPTION_POINTERS * _ExceptionPtr);



__declspec(dllimport) terminate_function __cdecl set_terminate(   terminate_function _NewPtFunc);
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(void);
__declspec(dllimport) unexpected_function __cdecl set_unexpected(   unexpected_function _NewPtFunc);
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(void);
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"



__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(   _se_translator_function _NewPtFunc);
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
__declspec(dllimport) bool __cdecl __uncaught_exception();









#pragma pack(pop)
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"





#pragma pack(push,8)


extern "C" {
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"







#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"





#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"













typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;

#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"



































#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"



  __declspec(dllimport)  __declspec(noalias) __declspec(restrict)    void * __cdecl calloc(  size_t _Count,   size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl free( void * _Memory);
  __declspec(dllimport)  __declspec(noalias) __declspec(restrict)                              void * __cdecl malloc(  size_t _Size);

  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                           void * __cdecl realloc( void * _Memory,   size_t _NewSize);

  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _recalloc( void * _Memory,   size_t _Count,   size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl _aligned_free( void * _Memory);
  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_malloc(  size_t _Size,   size_t _Alignment);
  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_malloc(  size_t _Size,   size_t _Alignment,   size_t _Offset);

  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_realloc( void * _Memory,   size_t _NewSize,   size_t _Alignment);

  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_recalloc( void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment);

  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_realloc( void * _Memory,   size_t _NewSize,   size_t _Alignment,   size_t _Offset);

  __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_offset_recalloc( void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment,   size_t _Offset);
 __declspec(dllimport)                                                  size_t __cdecl _aligned_msize( void * _Memory,   size_t _Alignment,   size_t _Offset);
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
















#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"

__declspec(dllimport) int     __cdecl _resetstkoflw (void);



__declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(  unsigned long _NewValue);








#line 156 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"

  __declspec(dllimport) void *  __cdecl _expand( void * _Memory,   size_t _NewSize);
 __declspec(dllimport) size_t  __cdecl _msize( void * _Memory);




#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"

 void *          __cdecl _alloca(  size_t _Size);
 __declspec(dllimport) int     __cdecl _heapadd(  void * _Memory,   size_t _Size);
 __declspec(dllimport) int     __cdecl _heapchk(void);
 __declspec(dllimport) int     __cdecl _heapmin(void);
__declspec(dllimport) int     __cdecl _heapset(  unsigned int _Fill);
__declspec(dllimport)  int     __cdecl _heapwalk(   _HEAPINFO * _EntryInfo);
__declspec(dllimport) size_t  __cdecl _heapused(size_t * _Used, size_t * _Commit);

__declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);











#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"

typedef char __static_assert_t[ (sizeof(unsigned int) <= 8) ];


#pragma warning(push)
#pragma warning(disable:6540)
__inline void *_MarkAllocaS(   void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + 8;
    }
    return _Ptr;
}
#pragma warning(pop)
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"







#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"







#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"








__declspec(noalias) __inline void __cdecl _freea( void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - 8;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == 0xDDDD)
        {
            free(_Memory);
        }





#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
    }
}
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"




#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"

#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"






















}
#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"

#pragma pack(pop)

#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
 

 

#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

 



































#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

 namespace std {





 
#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

class __declspec(dllimport) exception
    {   
public:
      exception();
     explicit  exception(const char * const &);
      exception(const char * const &, int);
      exception(const exception&);
     exception&  operator=(const exception&);
     virtual  ~exception();
     virtual const char *  what() const;

private:
     void  _Copy_str(const char *);
     void  _Tidy();

    const char * _Mywhat;
    bool _Mydofree;
    };

















































































using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);

__declspec(dllimport) bool __cdecl uncaught_exception();

}

 










































































































#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"


namespace std {


#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

		
class bad_exception : public exception
	{	
public:
	 bad_exception(const char *_Message = "bad exception")
		throw ()
		: exception(_Message)
		{	
		}

	virtual  ~bad_exception() throw ()
		{	
		}

 





#line 336 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

	};

		
class bad_alloc : public exception
	{	
public:
	 bad_alloc(const char *_Message) throw ()
		: exception(_Message)
		{	
		}

	 bad_alloc() throw ()
		: exception("bad allocation", 1)
		{	
		}

	virtual  ~bad_alloc() throw ()
		{	
		}

 





#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

	};


		
class bad_array_new_length
	: public bad_alloc
	{	
public:

	bad_array_new_length() throw ()
		: bad_alloc("bad array new length")
		{	
		}
	};
#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"


}









#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

__declspec(dllimport) void __cdecl __ExceptionPtrCreate(  void* );
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(   void* );
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(  void*,   const void* );
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(   void*,   const void* );
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);

__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(   void*,   const void*,   const void*);

namespace std {


typedef ::std:: nullptr_t _Null_type;


#line 411 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"

class _Exception_ptr
	{
public:
	_Exception_ptr()
		{
		__ExceptionPtrCreate(this);
		}
	_Exception_ptr(_Null_type)
		{
		__ExceptionPtrCreate(this);
		}
	~_Exception_ptr()
		{
		__ExceptionPtrDestroy(this);
		}
	_Exception_ptr(  const _Exception_ptr& _Rhs)
		{
		__ExceptionPtrCopy(this, const_cast<_Exception_ptr*>(&_Rhs));
		}
	_Exception_ptr& operator=(  const _Exception_ptr& _Rhs)
		{
		__ExceptionPtrAssign(this, const_cast<_Exception_ptr*>(&_Rhs));
		return *this;
		}
	_Exception_ptr& operator=(_Null_type)
		{
		_Exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	void _RethrowException() const
		{
		__ExceptionPtrRethrow(const_cast<_Exception_ptr*>(this));
		}

	static _Exception_ptr _Current_exception()
		{
		_Exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}
	static _Exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		_Exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}
private:
	void* _Data1;
	void* _Data2;
	};

inline bool operator==(  const _Exception_ptr& _Lhs,   const _Exception_ptr& _Rhs)
	{
	return __ExceptionPtrCompare(const_cast<_Exception_ptr*>(&_Lhs),const_cast<_Exception_ptr*>(&_Rhs));
	}

inline bool operator==(_Null_type,   const _Exception_ptr& _Rhs)
	{
	_Exception_ptr _Ptr;
	return __ExceptionPtrCompare(&_Ptr,const_cast<_Exception_ptr*>(&_Rhs));
	}

inline bool operator==(  const _Exception_ptr& _Lhs, _Null_type)
	{
	return operator==(0,_Lhs);
	}

typedef _Exception_ptr exception_ptr;

inline exception_ptr current_exception()
	{
	return _Exception_ptr::_Current_exception();
	}

inline void rethrow_exception(  exception_ptr _P)
	{
	_P._RethrowException();
	}

template <class _E> void *__GetExceptionInfo(_E);

template<class _E> exception_ptr copy_exception(_E _Except)
	{
	return _Exception_ptr::_Copy_exception(&_Except, __GetExceptionInfo(_Except));
	}

}







 #pragma warning(pop)
 #pragma pack(pop)

#line 517 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
#line 518 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  








#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

namespace std {

		
 




typedef void (__cdecl * new_handler) ();
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
 #line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

 
struct nothrow_t
	{	
	};

extern const nothrow_t nothrow;	
 #line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(   new_handler)
	throw ();	
}

		
void __cdecl operator delete(void *) throw ();
#pragma warning (suppress: 4985)
 void *__cdecl operator new(size_t _Size) throw (...);

 
  
inline void *__cdecl operator new(size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete(void *, void *) throw ()
	{	
	}
 #line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

 
  
inline void *__cdecl operator new[](size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete[](void *, void *) throw ()
	{	
	}
 #line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

void __cdecl operator delete[](void *) throw ();	

 void *__cdecl operator new[](size_t _Size)
	throw (...);	

 
  
 void *__cdecl operator new(size_t _Size, const ::std:: nothrow_t&)
	throw ();

 void *__cdecl operator new[](size_t _Size, const ::std:: nothrow_t&)
	throw ();	

void __cdecl operator delete(void *, const ::std:: nothrow_t&)
	throw ();	

void __cdecl operator delete[](void *, const ::std:: nothrow_t&)
	throw ();	
 #line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"


 
using ::std:: new_handler;
 #line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"





#line 78 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"






#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"



#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new( size_t, void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new[]( size_t, void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete(void*, void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete[](void*, void*) throw();



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"





#pragma pack(push,8)


extern "C" {
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

























struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"










#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"













#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"





















#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"













__declspec(dllimport) FILE * __cdecl __iob_func(void);
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"










#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"



typedef __int64 fpos_t;




#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"


#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"






#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
























 __declspec(dllimport) int __cdecl _filbuf(   FILE * _File );
 __declspec(dllimport) int __cdecl _flsbuf(  int _Ch,    FILE * _File);




 __declspec(dllimport) FILE * __cdecl _fsopen(   const char * _Filename,    const char * _Mode,   int _ShFlag);
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(   FILE * _File);

 __declspec(dllimport) errno_t __cdecl clearerr_s(   FILE * _File );
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fclose(   FILE * _File);
 __declspec(dllimport) int __cdecl _fcloseall(void);




 __declspec(dllimport) FILE * __cdecl _fdopen(  int _FileHandle,    const char * _Mode);
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) int __cdecl feof(  FILE * _File);
 __declspec(dllimport) int __cdecl ferror(  FILE * _File);
 __declspec(dllimport) int __cdecl fflush(   FILE * _File);
 __declspec(dllimport) int __cdecl fgetc(   FILE * _File);
 __declspec(dllimport) int __cdecl _fgetchar(void);
 __declspec(dllimport) int __cdecl fgetpos(   FILE * _File ,   fpos_t * _Pos);
 __declspec(dllimport) char * __cdecl fgets(    char * _Buf,   int _MaxCount,    FILE * _File);




 __declspec(dllimport) int __cdecl _fileno(  FILE * _File);
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"




#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) char * __cdecl _tempnam(   const char * _DirName,    const char * _FilePrefix);



#line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) int __cdecl _flushall(void);
  __declspec(dllimport) FILE * __cdecl fopen(   const char * _Filename,    const char * _Mode);

 __declspec(dllimport) errno_t __cdecl fopen_s(     FILE ** _File,    const char * _Filename,    const char * _Mode);
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fprintf(   FILE * _File,     const char * _Format, ...);

 __declspec(dllimport) int __cdecl fprintf_s(   FILE * _File,     const char * _Format, ...);
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fputc(  int _Ch,    FILE * _File);
 __declspec(dllimport) int __cdecl _fputchar(  int _Ch);
 __declspec(dllimport) int __cdecl fputs(   const char * _Str,    FILE * _File);
 __declspec(dllimport) size_t __cdecl fread(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,    FILE * _File);

 __declspec(dllimport) size_t __cdecl fread_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,    FILE * _File);
#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
  __declspec(dllimport) FILE * __cdecl freopen(   const char * _Filename,    const char * _Mode,    FILE * _File);

 __declspec(dllimport) errno_t __cdecl freopen_s(     FILE ** _File,    const char * _Filename,    const char * _Mode,    FILE * _OldFile);
#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
  __declspec(dllimport) int __cdecl fscanf(   FILE * _File,     const char * _Format, ...);
  __declspec(dllimport) int __cdecl _fscanf_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fscanf_s(   FILE * _File,     const char * _Format, ...);
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fscanf_s_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl fsetpos(   FILE * _File,   const fpos_t * _Pos);
 __declspec(dllimport) int __cdecl fseek(   FILE * _File,   long _Offset,   int _Origin);
 __declspec(dllimport) long __cdecl ftell(   FILE * _File);

 __declspec(dllimport) int __cdecl _fseeki64(   FILE * _File,   __int64 _Offset,   int _Origin);
 __declspec(dllimport) __int64 __cdecl _ftelli64(   FILE * _File);

 __declspec(dllimport) size_t __cdecl fwrite(   const void * _Str,   size_t _Size,   size_t _Count,    FILE * _File);
 __declspec(dllimport) int __cdecl getc(   FILE * _File);
 __declspec(dllimport) int __cdecl getchar(void);
 __declspec(dllimport) int __cdecl _getmaxstdio(void);

__declspec(dllimport) char * __cdecl gets_s(    char * _Buf,   rsize_t _Size);
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
 __declspec(dllimport) char * __cdecl gets(  char *_Buffer);
 int __cdecl _getw(   FILE * _File);


__declspec(dllimport) void __cdecl perror(   const char * _ErrMsg);
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _pclose(   FILE * _File);
 __declspec(dllimport) FILE * __cdecl _popen(   const char * _Command,    const char * _Mode);
 __declspec(dllimport) int __cdecl printf(    const char * _Format, ...);

 __declspec(dllimport) int __cdecl printf_s(    const char * _Format, ...);
#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl putc(  int _Ch,    FILE * _File);
 __declspec(dllimport) int __cdecl putchar(  int _Ch);
 __declspec(dllimport) int __cdecl puts(   const char * _Str);
 __declspec(dllimport) int __cdecl _putw(  int _Word,    FILE * _File);


__declspec(dllimport) int __cdecl remove(   const char * _Filename);
 __declspec(dllimport) int __cdecl rename(   const char * _OldFilename,    const char * _NewFilename);
__declspec(dllimport) int __cdecl _unlink(   const char * _Filename);

 __declspec(dllimport) int __cdecl unlink(   const char * _Filename);
#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
__declspec(dllimport) void __cdecl rewind(   FILE * _File);
 __declspec(dllimport) int __cdecl _rmtmp(void);
  __declspec(dllimport) int __cdecl scanf(    const char * _Format, ...);
  __declspec(dllimport) int __cdecl _scanf_l(    const char * _Format,    _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl scanf_s(    const char * _Format, ...);
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _scanf_s_l(    const char * _Format,    _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) void __cdecl setbuf(   FILE * _File,      char * _Buffer);
 __declspec(dllimport) int __cdecl _setmaxstdio(  int _Max);
 __declspec(dllimport) unsigned int __cdecl _set_output_format(  unsigned int _Format);
 __declspec(dllimport) unsigned int __cdecl _get_output_format(void);
 __declspec(dllimport) int __cdecl setvbuf(   FILE * _File,     char * _Buf,   int _Mode,   size_t _Size);
 __declspec(dllimport) int __cdecl _snprintf_s(    char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); } __pragma(warning(pop)); }

 __declspec(dllimport) int __cdecl sprintf_s(    char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, ...);
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(  char (&_Dest)[_Size],     const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
 __declspec(dllimport) int __cdecl _scprintf(    const char * _Format, ...);
  __declspec(dllimport) int __cdecl sscanf(   const char * _Src,     const char * _Format, ...);
  __declspec(dllimport) int __cdecl _sscanf_l(   const char * _Src,     const char * _Format,    _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl sscanf_s(   const char * _Src,     const char * _Format, ...);
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _sscanf_s_l(   const char * _Src,     const char * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _snscanf(     const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
  __declspec(dllimport) int __cdecl _snscanf_l(     const char * _Src,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snscanf_s(     const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _snscanf_s_l(     const char * _Src,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
#pragma warning(pop)
  __declspec(dllimport) FILE * __cdecl tmpfile(void);

 __declspec(dllimport) errno_t __cdecl tmpfile_s(    FILE ** _File);
 __declspec(dllimport) errno_t __cdecl tmpnam_s(    char * _Buf,   rsize_t _Size);
#line 343 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buf)[_Size]) throw() { return tmpnam_s(_Buf, _Size); } }
 __declspec(dllimport) char * __cdecl tmpnam(  char *_Buffer);
 __declspec(dllimport) int __cdecl ungetc(  int _Ch,    FILE * _File);
 __declspec(dllimport) int __cdecl vfprintf(   FILE * _File,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfprintf_s(   FILE * _File,     const char * _Format, va_list _ArgList);
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vprintf(    const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vprintf_s(    const char * _Format, va_list _ArgList);
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
  __declspec(dllimport) int __cdecl vsnprintf(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vsnprintf_s(    char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _vsnprintf_s(    char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
 __declspec(dllimport) int __cdecl _snprintf(   char *_Dest,   size_t _Count,     const char * _Format, ...);  __declspec(dllimport) int __cdecl _vsnprintf(   char *_Dest,   size_t _Count,     const char * _Format, va_list _Args);
#pragma warning(pop)

__declspec(dllimport) int __cdecl vsprintf_s(    char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(  char (&_Dest)[_Size],     const char * _Format, va_list _Args) throw() { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
 __declspec(dllimport) int __cdecl sprintf(  char *_Dest,  const char * _Format, ...);  __declspec(dllimport) int __cdecl vsprintf(  char *_Dest,  const char * _Format, va_list _Args);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl _vscprintf(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _snprintf_c(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vsnprintf_c(  char *_DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_p(   FILE * _File,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _printf_p(    const char * _Format, ...);
 __declspec(dllimport) int __cdecl _sprintf_p(    char * _Dst,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vfprintf_p(   FILE * _File,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p(    char * _Dst,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _scprintf_p(    const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vscprintf_p(    const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output(  int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output(void);

 __declspec(dllimport) int __cdecl _printf_l(    const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_p_l(    const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_s_l(    const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vprintf_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_s_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_p_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_s_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfprintf_l(   FILE * _File,    const char * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_p_l(   FILE * _File,    const char * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_s_l(   FILE * _File,    const char * _Format,    _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _sprintf_l(   char * _DstBuf,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_p_l(    char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_s_l(    char * _DstBuf,   size_t _DstSize,     const char * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vsprintf_l(   char * _DstBuf,    const char * _Format,    _locale_t, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p_l(    char * _DstBuf,   size_t _MaxCount,     const char* _Format,    _locale_t _Locale,  va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_s_l(    char * _DstBuf,   size_t _DstSize,     const char * _Format,    _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _scprintf_l(    const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _scprintf_p_l(    const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vscprintf_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vscprintf_p_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _snprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_c_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_s_l(    char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vsnprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_c_l(  char * _DstBuf,   size_t _MaxCount, const char *,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_s_l(    char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char* _Format,   _locale_t _Locale, va_list _ArgList);







#line 428 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"




 __declspec(dllimport) FILE * __cdecl _wfsopen(   const wchar_t * _Filename,    const wchar_t * _Mode,   int _ShFlag);
#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) wint_t __cdecl fgetwc(   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fgetwchar(void);
 __declspec(dllimport) wint_t __cdecl fputwc(  wchar_t _Ch,    FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwchar(  wchar_t _Ch);
 __declspec(dllimport) wint_t __cdecl getwc(   FILE * _File);
 __declspec(dllimport) wint_t __cdecl getwchar(void);
 __declspec(dllimport) wint_t __cdecl putwc(  wchar_t _Ch,    FILE * _File);
 __declspec(dllimport) wint_t __cdecl putwchar(  wchar_t _Ch);
 __declspec(dllimport) wint_t __cdecl ungetwc(  wint_t _Ch,    FILE * _File);

 __declspec(dllimport) wchar_t * __cdecl fgetws(    wchar_t * _Dst,   int _SizeInWords,    FILE * _File);
 __declspec(dllimport) int __cdecl fputws(   const wchar_t * _Str,    FILE * _File);
 __declspec(dllimport) wchar_t * __cdecl _getws_s(    wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(  wchar_t (&_String)[_Size]) throw() { return _getws_s(_String, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _getws(  wchar_t *_String);
 __declspec(dllimport) int __cdecl _putws(   const wchar_t * _Str);

 __declspec(dllimport) int __cdecl fwprintf(   FILE * _File,     const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl fwprintf_s(   FILE * _File,     const wchar_t * _Format, ...);
#line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl wprintf(    const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl wprintf_s(    const wchar_t * _Format, ...);
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _scwprintf(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl vfwprintf(   FILE * _File,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfwprintf_s(   FILE * _File,     const wchar_t * _Format, va_list _ArgList);
#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vwprintf(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vwprintf_s(    const wchar_t * _Format, va_list _ArgList);
#line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"


__declspec(dllimport) int __cdecl swprintf_s(    wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, ...);
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

__declspec(dllimport) int __cdecl vswprintf_s(    wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);
#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, va_list _Args) throw() { return vswprintf_s(_Dest, _Size, _Format, _Args); } }

 __declspec(dllimport) int __cdecl _swprintf_c(    wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c(    wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _snwprintf_s(    wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
 __declspec(dllimport) int __cdecl _vsnwprintf_s(    wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, va_list _Args) throw() { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
 __declspec(dllimport) int __cdecl _snwprintf(   wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, ...);  __declspec(dllimport) int __cdecl _vsnwprintf(   wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, va_list _Args);
#pragma warning(pop)

 __declspec(dllimport) int __cdecl _fwprintf_p(   FILE * _File,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _wprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_p(   FILE * _File,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _swprintf_p(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_p(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _scwprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vscwprintf_p(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _wprintf_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_s_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vwprintf_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_s_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fwprintf_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_p_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_s_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_p_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_s_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _swprintf_c_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_p_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_p_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _scwprintf_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _scwprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vscwprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _snwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vsnwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnwprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);










#line 540 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"


#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
 __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(   wchar_t *_Dest,     const wchar_t * _Format, ...);  __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(   wchar_t *_Dest,     const wchar_t * _Format, va_list _Args);
 __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l( wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, ...);  __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l( wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"












#pragma once







#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"










#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )


#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int swprintf(   wchar_t * _String,     const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int __cdecl vswprintf(   wchar_t * _String,     const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int _swprintf_l(   wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int __cdecl _vswprintf_l(   wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )

#pragma warning( pop )

#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"

#line 550 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#line 551 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"













#line 565 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) wchar_t * __cdecl _wtempnam(   const wchar_t * _Directory,    const wchar_t * _FilePrefix);



#line 571 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) int __cdecl _vscwprintf(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vscwprintf_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  __declspec(dllimport) int __cdecl fwscanf(   FILE * _File,     const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _fwscanf_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fwscanf_s(   FILE * _File,     const wchar_t * _Format, ...);
#line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fwscanf_s_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl swscanf(   const wchar_t * _Src,     const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _swscanf_l(   const wchar_t * _Src,     const wchar_t * _Format,    _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl swscanf_s(   const wchar_t *_Src,     const wchar_t * _Format, ...);
#line 587 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _swscanf_s_l(   const wchar_t * _Src,     const wchar_t * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _snwscanf(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _snwscanf_l(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s_l(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl wscanf(    const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _wscanf_l(    const wchar_t * _Format,    _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl wscanf_s(    const wchar_t * _Format, ...);
#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _wscanf_s_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
#pragma warning(pop)

 __declspec(dllimport) FILE * __cdecl _wfdopen(  int _FileHandle ,    const wchar_t * _Mode);
  __declspec(dllimport) FILE * __cdecl _wfopen(   const wchar_t * _Filename,    const wchar_t * _Mode);
 __declspec(dllimport) errno_t __cdecl _wfopen_s(     FILE ** _File,    const wchar_t * _Filename,    const wchar_t * _Mode);
  __declspec(dllimport) FILE * __cdecl _wfreopen(   const wchar_t * _Filename,    const wchar_t * _Mode,    FILE * _OldFile);
 __declspec(dllimport) errno_t __cdecl _wfreopen_s(     FILE ** _File,    const wchar_t * _Filename,    const wchar_t * _Mode,    FILE * _OldFile);



__declspec(dllimport) void __cdecl _wperror(   const wchar_t * _ErrMsg);
#line 610 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
 __declspec(dllimport) FILE * __cdecl _wpopen(   const wchar_t *_Command,    const wchar_t * _Mode);
__declspec(dllimport) int __cdecl _wremove(   const wchar_t * _Filename);
 __declspec(dllimport) errno_t __cdecl _wtmpnam_s(    wchar_t * _DstBuf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wtmpnam(  wchar_t *_Buffer);

 __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwc_nolock(  wchar_t _Ch,    FILE * _File);
 __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(  wint_t _Ch,    FILE * _File);






#line 626 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
inline wint_t __cdecl getwchar()
        {return (fgetwc((&__iob_func()[0]))); }   
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }       
#line 631 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"










#line 642 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"


#line 645 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"


#line 648 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"















#line 664 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"











__declspec(dllimport) void __cdecl _lock_file(   FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file(   FILE * _File);

 __declspec(dllimport) int __cdecl _fclose_nolock(   FILE * _File);
 __declspec(dllimport) int __cdecl _fflush_nolock(   FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,    FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,    FILE * _File);
 __declspec(dllimport) int __cdecl _fseek_nolock(   FILE * _File,   long _Offset,   int _Origin);
 __declspec(dllimport) long __cdecl _ftell_nolock(   FILE * _File);
 __declspec(dllimport) int __cdecl _fseeki64_nolock(   FILE * _File,   __int64 _Offset,   int _Origin);
 __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(   FILE * _File);
 __declspec(dllimport) size_t __cdecl _fwrite_nolock(   const void * _DstBuf,   size_t _Size,   size_t _Count,    FILE * _File);
 __declspec(dllimport) int __cdecl _ungetc_nolock(  int _Ch,    FILE * _File);












#line 701 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"











#line 713 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

 __declspec(dllimport) char * __cdecl tempnam(   const char * _Directory,    const char * _FilePrefix);



#line 719 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

  __declspec(dllimport) int __cdecl fcloseall(void);
  __declspec(dllimport) FILE * __cdecl fdopen(  int _FileHandle,    const char * _Format);
  __declspec(dllimport) int __cdecl fgetchar(void);
  __declspec(dllimport) int __cdecl fileno(  FILE * _File);
  __declspec(dllimport) int __cdecl flushall(void);
  __declspec(dllimport) int __cdecl fputchar(  int _Ch);
  __declspec(dllimport) int __cdecl getw(   FILE * _File);
  __declspec(dllimport) int __cdecl putw(  int _Ch,    FILE * _File);
  __declspec(dllimport) int __cdecl rmtmp(void);

#line 731 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"


}
#line 735 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

#pragma pack(pop)

#line 739 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"

#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"






#pragma pack(push,8)


extern "C" {
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"



















typedef int (__cdecl * _onexit_t)(void);



#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"



#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"




#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"






typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

typedef struct _lldiv_t {
        long long quot;
        long long rem;
} lldiv_t;


#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"










#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()













#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;





typedef struct {
        


        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()


#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"












__declspec(dllimport) extern int __mb_cur_max;



#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"





































typedef void (__cdecl *_purecall_handler)(void); 


__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(   _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);
#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


extern "C++"
{




#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
}
#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"



typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); 


__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(   _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


extern "C++"
{




#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
}
#line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"











__declspec(dllimport) unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno(  unsigned long _Value);
errno_t __cdecl _get_doserrno(  unsigned long * _Value);


__declspec(dllimport)  char ** __cdecl __sys_errlist(void);


__declspec(dllimport)  int * __cdecl __sys_nerr(void);




__declspec(dllimport) int *          __cdecl __p___argc(void);
__declspec(dllimport) char ***       __cdecl __p___argv(void);
__declspec(dllimport) wchar_t ***    __cdecl __p___wargv(void);
__declspec(dllimport) char ***       __cdecl __p__environ(void);
__declspec(dllimport) wchar_t ***    __cdecl __p__wenviron(void);
__declspec(dllimport) char **        __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t **     __cdecl __p__wpgmptr(void);


#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


__declspec(dllimport) extern int __argc;          
__declspec(dllimport) extern char ** __argv;      
__declspec(dllimport) extern wchar_t ** __wargv;  







#line 294 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"





__declspec(dllimport) extern char ** _environ;    
__declspec(dllimport) extern wchar_t ** _wenviron;    
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) extern char * _pgmptr;      
 __declspec(dllimport) extern wchar_t * _wpgmptr;  














#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

errno_t __cdecl _get_pgmptr(     char ** _Value);
errno_t __cdecl _get_wpgmptr(     wchar_t ** _Value);



 __declspec(dllimport) extern int _fmode;          



#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

__declspec(dllimport) errno_t __cdecl _set_fmode(  int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode(  int * _PMode);





#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 347 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"





__declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
__declspec(dllimport) void __cdecl abort(void);
#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(  unsigned int _Flags,   unsigned int _Mask);



        int       __cdecl abs(  int _X);
        long      __cdecl labs(  long _X);
        long long __cdecl llabs(  long long _X);
#line 366 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

        __int64    __cdecl _abs64(__int64);















#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"













#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
#line 400 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


 __declspec(dllimport) double  __cdecl atof(   const char *_String);
 __declspec(dllimport) double  __cdecl _atof_l(   const char *_String,    _locale_t _Locale);
#line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
 __declspec(dllimport)  int    __cdecl atoi(   const char *_Str);
 __declspec(dllimport) int    __cdecl _atoi_l(   const char *_Str,    _locale_t _Locale);
 __declspec(dllimport) long   __cdecl atol(   const char *_Str);
 __declspec(dllimport) long   __cdecl _atol_l(   const char *_Str,    _locale_t _Locale);



 __declspec(dllimport) void * __cdecl bsearch_s(  const void * _Key,    const void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) void * __cdecl bsearch(  const void * _Key,    const void * _Base, 
          size_t _NumOfElements,   size_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(const void *, const void *));


__declspec(dllimport) void __cdecl qsort_s(   void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
__declspec(dllimport) void __cdecl qsort(   void * _Base, 
	  size_t _NumOfElements,   size_t _SizeOfElements, 
          int (__cdecl * _PtFuncCompare)(const void *, const void *));
#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
         unsigned short __cdecl _byteswap_ushort(  unsigned short _Short);
         unsigned long  __cdecl _byteswap_ulong (  unsigned long _Long);
         unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Int64);
 __declspec(dllimport) div_t  __cdecl div(  int _Numerator,   int _Denominator);
 __declspec(dllimport)  char * __cdecl getenv(   const char * _VarName);

 __declspec(dllimport) errno_t __cdecl getenv_s(  size_t * _ReturnSize,     char * _DstBuf,   rsize_t _DstSize,    const char * _VarName);
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t * _ReturnSize, char (&_Dest)[_Size],    const char * _VarName) throw() { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }



#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _dupenv_s(    char **_PBuffer,   size_t * _PBufferSizeInBytes,    const char * _VarName);



#line 448 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _itoa_s(  int _Value,     char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(  int _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) char * __cdecl _itoa( int _Value,   char *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _i64toa_s(  __int64 _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport)  char * __cdecl _i64toa(  __int64 _Val,    char * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64toa_s(  unsigned __int64 _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport)  char * __cdecl _ui64toa(  unsigned __int64 _Val,    char * _DstBuf,   int _Radix);
 __declspec(dllimport) __int64 __cdecl _atoi64(   const char * _String);
 __declspec(dllimport) __int64 __cdecl _atoi64_l(   const char * _String,    _locale_t _Locale);
 __declspec(dllimport) __int64 __cdecl _strtoi64(   const char * _String,     char ** _EndPtr,   int _Radix);
 __declspec(dllimport) __int64 __cdecl _strtoi64_l(   const char * _String,     char ** _EndPtr,   int _Radix,    _locale_t _Locale);
 __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(   const char * _String,     char ** _EndPtr,   int _Radix);
 __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(   const char * _String,     char ** _EndPtr,   int  _Radix,    _locale_t _Locale);
 __declspec(dllimport) ldiv_t __cdecl ldiv(  long _Numerator,   long _Denominator);
 __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

extern "C++"
{
    inline long abs(long _X)
    {
        return labs(_X);
    }
    inline long long abs(long long _X)
    {
        return llabs(_X);
    }
    inline ldiv_t div(long _A1, long _A2)
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long _A1, long long _A2)
    {
        return lldiv(_A1, _A2);
    }
}
#line 485 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _ltoa_s(  long _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) char * __cdecl _ltoa( long _Value,   char *_Dest,  int _Radix);
 __declspec(dllimport) int    __cdecl mblen(     const char * _Ch,   size_t _MaxCount);
 __declspec(dllimport) int    __cdecl _mblen_l(     const char * _Ch,   size_t _MaxCount,    _locale_t _Locale);
 __declspec(dllimport) size_t __cdecl _mbstrlen(   const char * _Str);
 __declspec(dllimport) size_t __cdecl _mbstrlen_l(   const char *_Str,    _locale_t _Locale);
 __declspec(dllimport) size_t __cdecl _mbstrnlen(   const char *_Str,   size_t _MaxCount);
 __declspec(dllimport) size_t __cdecl _mbstrnlen_l(   const char *_Str,   size_t _MaxCount,    _locale_t _Locale);
__declspec(dllimport) int    __cdecl mbtowc(   wchar_t * _DstCh,      const char * _SrcCh,   size_t _SrcSizeInBytes);
__declspec(dllimport) int    __cdecl _mbtowc_l(   wchar_t * _DstCh,      const char * _SrcCh,   size_t _SrcSizeInBytes,    _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,     wchar_t * _DstBuf,   size_t _SizeInWords,      const char * _SrcBuf,   size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],    const char * _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
 __declspec(dllimport) size_t __cdecl mbstowcs(  wchar_t *_Dest,  const char * _Source,  size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted,     wchar_t * _DstBuf,   size_t _SizeInWords,      const char * _SrcBuf,   size_t _MaxCount,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size],    const char * _Source,   size_t _MaxCount,    _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
 __declspec(dllimport) size_t __cdecl _mbstowcs_l(    wchar_t *_Dest,    const char * _Source,   size_t _MaxCount,    _locale_t _Locale);

 __declspec(dllimport) int    __cdecl rand(void);


#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) int    __cdecl _set_error_mode(  int _Mode);

__declspec(dllimport) void   __cdecl srand(  unsigned int _Seed);
 __declspec(dllimport) double __cdecl strtod(   const char * _Str,     char ** _EndPtr);
 __declspec(dllimport) double __cdecl _strtod_l(   const char * _Str,     char ** _EndPtr,    _locale_t _Locale);
 __declspec(dllimport) long   __cdecl strtol(   const char * _Str,     char ** _EndPtr,   int _Radix );
 __declspec(dllimport) long   __cdecl _strtol_l(   const char *_Str,     char **_EndPtr,   int _Radix,    _locale_t _Locale);
 __declspec(dllimport) unsigned long __cdecl strtoul(   const char * _Str,     char ** _EndPtr,   int _Radix);
 __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str,     char **_EndPtr,   int _Radix,    _locale_t _Locale);


__declspec(dllimport) int __cdecl system(   const char * _Command);
#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _ultoa_s(  unsigned long _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) char * __cdecl _ultoa( unsigned long _Value,   char *_Dest,  int _Radix);
__declspec(dllimport)  int    __cdecl wctomb(    char * _MbCh,   wchar_t _WCh);
__declspec(dllimport)  int    __cdecl _wctomb_l(   char * _MbCh,   wchar_t _WCh,    _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl wctomb_s(  int * _SizeConverted,     char * _MbCh,   rsize_t _SizeInBytes,   wchar_t _WCh);
#line 530 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _wctomb_s_l(  int * _SizeConverted,     char * _MbCh,   size_t _SizeInBytes,   wchar_t _WCh,    _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,     char * _Dst,   size_t _DstSizeInBytes,    const wchar_t * _Src,   size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],    const wchar_t * _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
 __declspec(dllimport) size_t __cdecl wcstombs(  char *_Dest,  const wchar_t * _Source,  size_t _MaxCount);
 __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,     char * _Dst,   size_t _DstSizeInBytes,    const wchar_t * _Src,   size_t _MaxCountInBytes,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],    const wchar_t * _Source,   size_t _MaxCount,    _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
 __declspec(dllimport) size_t __cdecl _wcstombs_l(    char *_Dest,    const wchar_t * _Source,   size_t _MaxCount,    _locale_t _Locale);

























#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
















































































 __declspec(dllimport) errno_t __cdecl _itow_s (  int _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) wchar_t * __cdecl _itow( int _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ltow_s (  long _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) wchar_t * __cdecl _ltow( long _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ultow_s (  unsigned long _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) wchar_t * __cdecl _ultow( unsigned long _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) double __cdecl wcstod(   const wchar_t * _Str,     wchar_t ** _EndPtr);
 __declspec(dllimport) double __cdecl _wcstod_l(   const wchar_t *_Str,     wchar_t ** _EndPtr,    _locale_t _Locale);
 __declspec(dllimport) long   __cdecl wcstol(   const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
 __declspec(dllimport) long   __cdecl _wcstol_l(   const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,    _locale_t _Locale);
 __declspec(dllimport) unsigned long __cdecl wcstoul(   const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
 __declspec(dllimport) unsigned long __cdecl _wcstoul_l(   const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,    _locale_t _Locale);
 __declspec(dllimport)  wchar_t * __cdecl _wgetenv(   const wchar_t * _VarName);
 __declspec(dllimport) errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize,     wchar_t * _DstBuf,   size_t _DstSizeInWords,    const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize, wchar_t (&_Dest)[_Size],    const wchar_t * _VarName) throw() { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }




#line 666 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wdupenv_s(    wchar_t **_Buffer,   size_t *_BufferSizeInWords,    const wchar_t *_VarName);



#line 672 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"



__declspec(dllimport) int __cdecl _wsystem(   const wchar_t * _Command);
#line 677 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) double __cdecl _wtof(   const wchar_t *_Str);
 __declspec(dllimport) double __cdecl _wtof_l(   const wchar_t *_Str,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _wtoi(   const wchar_t *_Str);
 __declspec(dllimport) int __cdecl _wtoi_l(   const wchar_t *_Str,    _locale_t _Locale);
 __declspec(dllimport) long __cdecl _wtol(   const wchar_t *_Str);
 __declspec(dllimport) long __cdecl _wtol_l(   const wchar_t *_Str,    _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl _i64tow_s(  __int64 _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport)  wchar_t * __cdecl _i64tow(  __int64 _Val,    wchar_t * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64tow_s(  unsigned __int64 _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport)  wchar_t * __cdecl _ui64tow(  unsigned __int64 _Val,    wchar_t * _DstBuf,   int _Radix);
 __declspec(dllimport) __int64   __cdecl _wtoi64(   const wchar_t *_Str);
 __declspec(dllimport) __int64   __cdecl _wtoi64_l(   const wchar_t *_Str,    _locale_t _Locale);
 __declspec(dllimport) __int64   __cdecl _wcstoi64(   const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
 __declspec(dllimport) __int64   __cdecl _wcstoi64_l(   const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix,    _locale_t _Locale);
 __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64(   const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
 __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64_l(   const wchar_t *_Str ,     wchar_t ** _EndPtr,   int _Radix,    _locale_t _Locale);


#line 697 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"














#line 712 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) char * __cdecl _fullpath(    char * _FullPath,    const char * _Path,   size_t _SizeInBytes);





#line 720 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ecvt_s(    char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDights,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
 __declspec(dllimport)  char * __cdecl _ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
 __declspec(dllimport) errno_t __cdecl _fcvt_s(    char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
 __declspec(dllimport)  char * __cdecl _fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s(    char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits) throw() { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport)  char * __cdecl _gcvt(  double _Val,   int _NumOfDigits,    char * _DstBuf);

 __declspec(dllimport) int __cdecl _atodbl(  _CRT_DOUBLE * _Result,    char * _Str);
 __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE * _Result,    char * _Str);
 __declspec(dllimport) int __cdecl _atoflt(  _CRT_FLOAT * _Result,    char * _Str);
 __declspec(dllimport) int __cdecl _atodbl_l(  _CRT_DOUBLE * _Result,    char * _Str,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _atoldbl_l(  _LDOUBLE * _Result,    char * _Str,    _locale_t _Locale);
 __declspec(dllimport) int __cdecl _atoflt_l(  _CRT_FLOAT * _Result,    char * _Str,    _locale_t _Locale);
         unsigned long __cdecl _lrotl(  unsigned long _Val,   int _Shift);
         unsigned long __cdecl _lrotr(  unsigned long _Val,   int _Shift);
 __declspec(dllimport) errno_t   __cdecl _makepath_s(    char * _PathResult,   size_t _SizeInWords,    const char * _Drive,    const char * _Dir,    const char * _Filename,
           const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size],    const char * _Drive,    const char * _Dir,    const char * _Filename,    const char * _Ext) throw() { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
 __declspec(dllimport) void __cdecl _makepath(  char *_Path,  const char * _Drive,  const char * _Dir,  const char * _Filename,  const char * _Ext);












#line 756 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"












#line 769 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(   _onexit_t _Func);
#line 771 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
        





#pragma warning (push)
#pragma warning (disable:6540) 
 __declspec(dllimport) int    __cdecl _putenv(   const char * _EnvString);
 __declspec(dllimport) errno_t __cdecl _putenv_s(   const char * _Name,    const char * _Value);
         unsigned int __cdecl _rotl(  unsigned int _Val,   int _Shift);
         unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Val,   int _Shift);
         unsigned int __cdecl _rotr(  unsigned int _Val,   int _Shift);
         unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Val,   int _Shift);
#pragma warning (pop)

__declspec(dllimport) errno_t __cdecl _searchenv_s(   const char * _Filename,    const char * _EnvVar,     char * _ResultPath,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(   const char * _Filename,    const char * _EnvVar, char (&_ResultPath)[_Size]) throw() { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
 __declspec(dllimport) void __cdecl _searchenv( const char * _Filename,  const char * _EnvVar,   char *_ResultPath);

 __declspec(dllimport) void   __cdecl _splitpath(   const char * _FullPath,    char * _Drive,    char * _Dir,    char * _Filename,    char * _Ext);
 __declspec(dllimport) errno_t  __cdecl _splitpath_s(   const char * _FullPath, 
		    char * _Drive,   size_t _DriveSize, 
		    char * _Dir,   size_t _DirSize, 
		    char * _Filename,   size_t _FilenameSize, 
		    char * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(  const char *_Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

__declspec(dllimport) void   __cdecl _swab(     char * _Buf1,      char * _Buf2, int _SizeInBytes);








#line 809 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) wchar_t * __cdecl _wfullpath(    wchar_t * _FullPath,    const wchar_t * _Path,   size_t _SizeInWords);



#line 815 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wmakepath_s(    wchar_t * _PathResult,   size_t _SIZE,    const wchar_t * _Drive,    const wchar_t * _Dir,    const wchar_t * _Filename,
           const wchar_t * _Ext);        
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size],    const wchar_t * _Drive,    const wchar_t * _Dir,    const wchar_t * _Filename,    const wchar_t * _Ext) throw() { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
 __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_ResultPath,  const wchar_t * _Drive,  const wchar_t * _Dir,  const wchar_t * _Filename,  const wchar_t * _Ext);




 __declspec(dllimport) int    __cdecl _wputenv(   const wchar_t * _EnvString);
 __declspec(dllimport) errno_t __cdecl _wputenv_s(   const wchar_t * _Name,    const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(   const wchar_t * _Filename,    const wchar_t * _EnvVar,     wchar_t * _ResultPath,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(   const wchar_t * _Filename,    const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
 __declspec(dllimport) void __cdecl _wsearchenv( const wchar_t * _Filename,  const wchar_t * _EnvVar,   wchar_t *_ResultPath);
 __declspec(dllimport) void   __cdecl _wsplitpath(   const wchar_t * _FullPath,    wchar_t * _Drive,    wchar_t * _Dir,    wchar_t * _Filename,    wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(   const wchar_t * _FullPath, 
		    wchar_t * _Drive,   size_t _DriveSize, 
		    wchar_t * _Dir,   size_t _DirSize, 
		    wchar_t * _Filename,   size_t _FilenameSize, 
		    wchar_t * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(  const wchar_t *_Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }


#line 839 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(  int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(  unsigned _Frequency,   unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(  unsigned long _Duration);

#line 846 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
















#pragma warning(push)
#pragma warning(disable: 4141)  
   __declspec(dllimport) char * __cdecl ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
   __declspec(dllimport) char * __cdecl fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
 		__declspec(dllimport) char * __cdecl gcvt(  double _Val,   int _NumOfDigits,    char * _DstBuf);
 		__declspec(dllimport) char * __cdecl itoa(  int _Val,    char * _DstBuf,   int _Radix);
 		__declspec(dllimport) char * __cdecl ltoa(  long _Val,    char * _DstBuf,   int _Radix);
  __declspec(dllimport) int    __cdecl putenv(   const char * _EnvString);
										__declspec(dllimport) void   __cdecl swab(    char * _Buf1,    char * _Buf2,   int _SizeInBytes);
 	__declspec(dllimport) char * __cdecl ultoa(  unsigned long _Val,    char * _Dstbuf,   int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit(   _onexit_t _Func);

#line 876 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

#line 878 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"


}

#line 883 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

#pragma pack(pop)

#line 887 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"

#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

extern "C"
{
extern __declspec(dllimport) __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) int     __cdecl printf(const char*, ...);
extern __declspec(dllimport) __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) int     __cdecl fprintf(FILE*, const char*, ...);
extern __declspec(dllimport) __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl malloc(size_t) ;
extern __declspec(dllimport) __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl free(void*) ;

}

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\assert.h"













#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\assert.h"










extern "C" {
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\assert.h"

__declspec(dllimport) void __cdecl _wassert(   const wchar_t * _Message,    const wchar_t *_File,   unsigned _Line);


}
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\assert.h"



#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\assert.h"
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

extern "C"
{




#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"


#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"



#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(dllimport) void __cdecl _wassert(
  const wchar_t *, const wchar_t *, unsigned);
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"
}









#line 140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"



#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new( size_t) throw(...);
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void*   __cdecl operator new[]( size_t) throw(...);
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete(void*) throw();
extern         __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) void    __cdecl operator delete[](void*) throw();



#line 153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"



#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"








#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"







extern "C"
{






















































#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) int            __cdecl abs(int) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) long int       __cdecl labs(long int) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) long long int          llabs(long long int) ;
#line 153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl fabs(double x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fabsf(float x) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    min(int, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned int           umin(unsigned int, unsigned int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llmin(long long int, long long int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned long long int ullmin(unsigned long long int, unsigned long long int);
















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fminf(float x, float y) ;


#line 260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fmin(double x, double y) ;


#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    max(int, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned int           umax(unsigned int, unsigned int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llmax(long long int, long long int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned long long int ullmax(unsigned long long int, unsigned long long int);
















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fmaxf(float x, float y) ;


#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fmax(double, double) ;


#line 324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sin(double x) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl cos(double x) ;














extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincos(double x, double *sptr, double *cptr) ;















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincosf(float x, float *sptr, float *cptr) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl tan(double x) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sqrt(double x) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rsqrt(double x);




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rsqrtf(float x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 log2(double x) ;


#line 732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 exp2(double x) ;


#line 757 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  exp2f(float x) ;


#line 782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



















         
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 exp10(double x) ;





















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  exp10f(float x) ;









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 expm1(double x) ;


#line 870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  expm1f(float x) ;        


#line 915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  log2f(float x) ;         


#line 970 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl log10(double x) ;






































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl log(double x) ;





























































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 log1p(double x) ;


#line 1189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





























































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  log1pf(float x) ;


#line 1286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl floor(double x) ;






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl exp(double x) ;






























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl cosh(double x) ;





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sinh(double x) ;





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl tanh(double x) ;


































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 acosh(double x) ;


#line 1526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  acoshf(float x) ;


#line 1564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 asinh(double x) ;


#line 1580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  asinhf(float x) ;


#line 1596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 atanh(double x) ;


#line 1650 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  atanhf(float x) ;


#line 1704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl ldexp(double x, int exp) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ldexpf(float x, int exp) ;



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 logb(double x) ;


#line 1871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  logbf(float x) ;


#line 1926 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    ilogb(double x) ;


#line 1956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    ilogbf(float x) ;


#line 1986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"








































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 scalbn(double x, int n) ;


#line 2062 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"








































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  scalbnf(float x, int n) ;


#line 2138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"








































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 scalbln(double x, long int n) ;


#line 2214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"








































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  scalblnf(float x, long int n) ;


#line 2290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl frexp(double x, int *nptr) ;










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  frexpf(float x, int *nptr) ;













extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 round(double x) ;


#line 2457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"













extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  roundf(float x) ;


#line 2474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lround(double x) ;


#line 2492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lroundf(float x) ;


#line 2510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llround(double x) ;


#line 2528 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llroundf(float x) ;


#line 2546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rint(double x) ;


#line 2561 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rintf(float x) ;


#line 2576 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lrint(double x) ;


#line 2592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lrintf(float x) ;


#line 2608 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llrint(double x) ;


#line 2624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llrintf(float x) ;


#line 2640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 nearbyint(double x) ;


#line 2693 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  nearbyintf(float x) ;


#line 2746 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl ceil(double x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 trunc(double x) ;


#line 2820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  truncf(float x) ;


#line 2835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"






















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fdim(double x, double y) ;


#line 2861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"






















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fdimf(float x, float y) ;


#line 2887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl atan2(double y, double x) ;






























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl atan(double x) ;






















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl acos(double x) ;































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl asin(double x) ;








































#line 3047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
static __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double       __cdecl hypot(double x, double y) ;
#line 3049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                rhypot(double x, double y) ;









































#line 3138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
static __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float        __cdecl hypotf(float x, float y) ;
#line 3140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                 rhypotf(float x, float y) ;



















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 cbrt(double x) ;


#line 3274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cbrtf(float x) ;


#line 3360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rcbrt(double x);
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rcbrtf(float x);



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 sinpi(double x);



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinpif(float x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 cospi(double x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cospif(float x);





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincospi(double x, double *sptr, double *cptr);





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincospif(float x, float *sptr, float *cptr);



















































































































































































































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl pow(double x, double y) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl modf(double x, double *iptr) ;


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl fmod(double x, double y) ;





















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 remainder(double x, double y) ;


#line 4254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"






















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  remainderf(float x, float y) ;


#line 4344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 remquo(double x, double y, int *quo) ;


#line 4398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  remquof(float x, float y, int *quo) ;


#line 4452 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl j0(double x) ;





































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  j0f(float x) ;
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl j1(double x) ;
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  j1f(float x) ;






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl jn(int n, double x) ;






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  jnf(int n, float x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl y0(double x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  y0f(float x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl y1(double x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  y1f(float x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl yn(int n, double x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ynf(int n, float x) ;


























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl cyl_bessel_i0(double x) ;

























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cyl_bessel_i0f(float x) ;


























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl cyl_bessel_i1(double x) ;

























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cyl_bessel_i1f(float x) ;















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erf(double x) ;


#line 5199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"














































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erff(float x) ;


#line 5281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfinv(double y);
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfinvf(float y);


































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfc(double x) ;


#line 5433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcf(float x) ;


#line 5471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"




























































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 lgamma(double x) ;


#line 5599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfcinv(double y);























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcinvf(float y);

























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 normcdfinv(double y);

























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  normcdfinvf(float y);










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 normcdf(double y);










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  normcdff(float y);










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfcx(double x);










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcxf(float x);

































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  lgammaf(float x) ;


#line 6196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"









































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 tgamma(double x) ;


#line 6305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"









































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  tgammaf(float x) ;


#line 6414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"









extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 copysign(double x, double y) ;


#line 6427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"









extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  copysignf(float x, float y) ;


#line 6440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 nextafter(double x, double y) ;


#line 6477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  nextafterf(float x, float y) ;


#line 6514 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 nan(const char *tagp) ;


#line 6530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  nanf(const char *tagp) ;


#line 6546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinff(float) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnanf(float) ;







#line 6556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finite(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finitef(float) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbit(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnan(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinf(double) ;
#line 6562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbitf(float) ;


























































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fma(double x, double y, double z) ;


#line 6722 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


























































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fmaf(float x, float y, float z) ;


#line 6880 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"




extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbitl(long double) ;




#line 6890 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finitel(long double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinfl(long double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnanl(long double) ;
#line 6894 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





















#line 6916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  acosf(float x) ;







































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  asinf(float x) ;







































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  atanf(float x) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  atan2f(float y, float x) ;























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cosf(float x) ;









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinf(float x) ;









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  tanf(float x) ;























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  coshf(float x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinhf(float x) ;





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  tanhf(float x) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  logf(float x) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  expf(float x) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  log10f(float x) ;






















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  modff(float x, float *iptr) ;



















































































































































































































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  powf(float x, float y) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sqrtf(float x) ;         


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ceilf(float x) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  floorf(float x) ;


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fmodf(float x, float y) ;
#line 8031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

}

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

















#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"














 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"





#pragma pack(push,8)


extern "C" {
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"








struct _exception {
        int type;       
        char *name;     
        double arg1;    
        double arg2;    
        double retval;  
        } ;


#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"







struct _complex {
        double x,y; 
        } ;




#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"


#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"






















__declspec(dllimport) extern double _HUGE;


#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"













        double  __cdecl acos(  double _X);
        double  __cdecl asin(  double _X);
        double  __cdecl atan(  double _X);
        double  __cdecl atan2(  double _Y,   double _X);

 __declspec(dllimport) double __cdecl _copysign (  double _Number,   double _Sign);
 __declspec(dllimport) double __cdecl _chgsign (  double _X);

#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
        double  __cdecl cos(  double _X);
        double  __cdecl cosh(  double _X);
        double  __cdecl exp(  double _X);
 double  __cdecl fabs(  double _X);
        double  __cdecl fmod(  double _X,   double _Y);
        double  __cdecl log(  double _X);
        double  __cdecl log10(  double _X);
        double  __cdecl pow(  double _X,   double _Y);
        double  __cdecl sin(  double _X);
        double  __cdecl sinh(  double _X);
        double  __cdecl tan(  double _X);
        double  __cdecl tanh(  double _X);
        double  __cdecl sqrt(  double _X);






__declspec(dllimport) double  __cdecl _cabs(  struct _complex _Complex_value);
__declspec(dllimport) double  __cdecl ceil(  double _X);
__declspec(dllimport) double  __cdecl floor(  double _X);
__declspec(dllimport) double  __cdecl frexp(  double _X,   int * _Y);
__declspec(dllimport) double  __cdecl _hypot(  double _X,   double _Y);
__declspec(dllimport) float   __cdecl _hypotf(  float _X,   float _Y);
__declspec(dllimport) double  __cdecl _j0(  double _X );
__declspec(dllimport) double  __cdecl _j1(  double _X );
__declspec(dllimport) double  __cdecl _jn(int _X,   double _Y);
__declspec(dllimport) double  __cdecl ldexp(  double _X,   int _Y);




#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
        int     __cdecl _matherr(   struct _exception * _Except);
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
__declspec(dllimport) double  __cdecl modf(  double _X,   double * _Y);

__declspec(dllimport) double  __cdecl _y0(  double _X);
__declspec(dllimport) double  __cdecl _y1(  double _X);
__declspec(dllimport) double  __cdecl _yn(  int _X,   double _Y);




static __inline double __cdecl hypot(  double _X,   double _Y)
{
    return _hypot(_X, _Y);
}

static __inline float __cdecl hypotf(  float _X,   float _Y)
{
    return _hypotf(_X, _Y);
}

#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"



__declspec(dllimport) int     __cdecl _set_SSE2_enable(  int _Flag);

#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"






































#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"











































#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"



































































inline long double acosl(  long double _X)
        {return (acos((double)_X)); }
inline long double asinl(  long double _X)
        {return (asin((double)_X)); }
inline long double atanl(  long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(  long double _Y,   long double _X)
        {return (atan2((double)_Y, (double)_X)); }
inline long double ceill(  long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(  long double _X)
        {return (cos((double)_X)); }
inline long double coshl(  long double _X)
        {return (cosh((double)_X)); }
inline long double expl(  long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(  long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(  long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(  long double _X,   long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(  long double _X,   int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(  long double _X,   int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(  long double _X)
        {return (log((double)_X)); }
inline long double log10l(  long double _X)
        {return (log10((double)_X)); }
inline long double modfl(  long double _X,   long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(  long double _X,   long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(  long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(  long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(  long double _X)
        {return (sqrt((double)_X)); }

inline long double tanl(  long double _X)
        {return (tan((double)_X)); }


#line 376 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

inline long double tanhl(  long double _X)
        {return (tanh((double)_X)); }

inline long double _chgsignl(  long double _Number)
{
    return _chgsign(static_cast<double>(_Number)); 
}

inline long double _copysignl(  long double _Number,   long double _Sign)
{
    return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign)); 
}

inline float frexpf(  float _X,   int *_Y)
        {return ((float)frexp((double)_X, _Y)); }


inline float fabsf(  float _X)
        {return ((float)fabs((double)_X)); }
inline float ldexpf(  float _X,   int _Y)
        {return ((float)ldexp((double)_X, _Y)); }

inline float acosf(  float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(  float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(  float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(  float _Y,   float _X)
        {return ((float)atan2((double)_Y, (double)_X)); }
inline float ceilf(  float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(  float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(  float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(  float _X)
        {return ((float)exp((double)_X)); }
inline float floorf(  float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(  float _X,   float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(  float _X)
        {return ((float)log((double)_X)); }
inline float log10f(  float _X)
        {return ((float)log10((double)_X)); }
inline float modff(  float _X,   float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(  float _X,   float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(  float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(  float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(  float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(  float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(  float _X)
        {return ((float)tanh((double)_X)); }
#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

















__declspec(dllimport) extern double HUGE;


#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

 __declspec(dllimport) double  __cdecl cabs(  struct _complex _X);
 __declspec(dllimport) double  __cdecl j0(  double _X);
 __declspec(dllimport) double  __cdecl j1(  double _X);
 __declspec(dllimport) double  __cdecl jn(  int _X,   double _Y);
 __declspec(dllimport) double  __cdecl y0(  double _X);
 __declspec(dllimport) double  __cdecl y1(  double _X);
 __declspec(dllimport) double  __cdecl yn(  int _X,   double _Y);

#line 474 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

#line 476 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"


}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline double __cdecl abs(  double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(  double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(  float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(  float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(  float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(  float _Y,   float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(  float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(  float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(  float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(  float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(  float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(  float _X,   float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(  float _X,   int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(  float _X,   int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(  float _X)
        {return (logf(_X)); }
inline float __cdecl log10(  float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(  float _X,   float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(  float _X,   float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(  float _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(  float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(  float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(  float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(  float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(  float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(  long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(  long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(  long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(  long double _Y,   long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(  long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(  long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(  long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(  long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(  long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(  long double _X,   long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(  long double _X,   int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(  long double _X,   int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(  long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(  long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(  long double _X,   long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(  long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(  long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(  long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(  long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(  long double _X)
        {return (tanhl(_X)); }

}
#line 598 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

#pragma pack(pop)

#line 602 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"







































#line 642 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

#line 8035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"

#pragma once










 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
































































































































































































































































































































































































































































































































































































































































#line 642 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"

 

namespace std {
using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: abs;

using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;
}
 #line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"

#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"





#line 8039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdlib"

#pragma once










 
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdlib"

 

namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;

using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free; using :: getenv;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul; using :: system;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

using :: llabs; using :: lldiv;
}
 #line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdlib"

#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdlib"





#line 8040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
#line 8041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





















































































































#line 8159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"








#line 8168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(dllimport) double __cdecl _hypot(double x, double y);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(dllimport) float  __cdecl _hypotf(float x, float y);

#line 8173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


static __inline __declspec(__host__) __declspec(__device__) int signbit(long double a)
{
  return __signbitl(a);
}



#line 8183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















static __inline __declspec(__host__) __declspec(__device__) int signbit(double a)
{
  return __signbit(a);
}



















#line 8225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















static __inline __declspec(__host__) __declspec(__device__) int signbit(float a)
{
  return __signbitf(a);
}



















#line 8267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


static __inline __declspec(__host__) __declspec(__device__) int isinf(long double a)
{
  return __isinfl(a);
}









#line 8283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

















static __inline __declspec(__host__) __declspec(__device__) int isinf(double a)
{
  return __isinf(a);
}
























#line 8329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















static __inline __declspec(__host__) __declspec(__device__) int isinf(float a)
{
  return __isinff(a);
}

























#line 8377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


static __inline __declspec(__host__) __declspec(__device__) int isnan(long double a)
{
  return __isnanl(a);
}









#line 8393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"
















static __inline __declspec(__host__) __declspec(__device__) int isnan(double a)
{
  return __isnan(a);
}























#line 8437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

















static __inline __declspec(__host__) __declspec(__device__) int isnan(float a)
{
  return __isnanf(a);
}

























#line 8484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


static __inline __declspec(__host__) __declspec(__device__) int isfinite(long double a)
{
  return __finitel(a);
}









#line 8500 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


















static __inline __declspec(__host__) __declspec(__device__) int isfinite(double a)
{
  return __finite(a);
}

























#line 8548 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

















static __inline __declspec(__host__) __declspec(__device__) int isfinite(float a)
{
  return __finitef(a);
}
























#line 8594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


template<class T> extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) T _Pow_int(T, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int abs(long long int);



#line 8602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

#line 8604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



#line 8608 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"







#line 8616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int __cdecl abs(long int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl abs(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double   __cdecl abs(double);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl fabs(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl ceil(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl floor(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sqrt(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl pow(float, float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl pow(float, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double   __cdecl pow(double, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl log(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl log10(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl fmod(float, float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl modf(float, float*);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl exp(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl frexp(float, int*);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl ldexp(float, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl asin(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sin(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sinh(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl acos(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl cos(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl cosh(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl atan(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl atan2(float, float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl tan(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl tanh(float);




























#line 8674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



#line 8678 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"


static __inline __declspec(__host__) __declspec(__device__) float logb(float a)
{
  return logbf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int ilogb(float a)
{
  return ilogbf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float scalbn(float a, int b)
{
  return scalbnf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float scalbln(float a, long int b)
{
  return scalblnf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float exp2(float a)
{
  return exp2f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float expm1(float a)
{
  return expm1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float log2(float a)
{
  return log2f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float log1p(float a)
{
  return log1pf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float acosh(float a)
{
  return acoshf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float asinh(float a)
{
  return asinhf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float atanh(float a)
{
  return atanhf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float hypot(float a, float b)
{
  return hypotf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float cbrt(float a)
{
  return cbrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erf(float a)
{
  return erff(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfc(float a)
{
  return erfcf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float lgamma(float a)
{
  return lgammaf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float tgamma(float a)
{
  return tgammaf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float copysign(float a, float b)
{
  return copysignf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float nextafter(float a, float b)
{
  return nextafterf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float remainder(float a, float b)
{
  return remainderf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float remquo(float a, float b, int *quo)
{
  return remquof(a, b, quo);
}

static __inline __declspec(__host__) __declspec(__device__) float round(float a)
{
  return roundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long int lround(float a)
{
  return lroundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long long int llround(float a)
{
  return llroundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float trunc(float a)
{
  return truncf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rint(float a)
{
  return rintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long int lrint(float a)
{
  return lrintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long long int llrint(float a)
{
  return llrintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float nearbyint(float a)
{
  return nearbyintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float fdim(float a, float b)
{
  return fdimf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float fma(float a, float b, float c)
{
  return fmaf(a, b, c);
}

static __inline __declspec(__host__) __declspec(__device__) float fmax(float a, float b)
{
  return fmaxf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float fmin(float a, float b)
{
  return fminf(a, b);
}


































#line 8879 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

static __inline __declspec(__host__) __declspec(__device__) float exp10(float a)
{
  return exp10f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rsqrt(float a)
{
  return rsqrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rcbrt(float a)
{
  return rcbrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float sinpi(float a)
{
  return sinpif(a);
}

static __inline __declspec(__host__) __declspec(__device__) float cospi(float a)
{
  return cospif(a);
}

static __inline __declspec(__host__) __declspec(__device__) void sincospi(float a, float *sptr, float *cptr)
{
  sincospif(a, sptr, cptr);
}

static __inline __declspec(__host__) __declspec(__device__) void sincos(float a, float *sptr, float *cptr)
{
  sincosf(a, sptr, cptr);
}

static __inline __declspec(__host__) __declspec(__device__) float j0(float a)
{
  return j0f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float j1(float a)
{
  return j1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float jn(int n, float a)
{
  return jnf(n, a);
}

static __inline __declspec(__host__) __declspec(__device__) float y0(float a)
{
  return y0f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float y1(float a)
{
  return y1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float yn(int n, float a)
{ 
  return ynf(n, a);
}

static __inline __declspec(__host__) __declspec(__device__) float cyl_bessel_i0(float a)
{
  return cyl_bessel_i0f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float cyl_bessel_i1(float a)
{
  return cyl_bessel_i1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfinv(float a)
{
  return erfinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfcinv(float a)
{
  return erfcinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float normcdfinv(float a)
{
  return normcdfinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float normcdf(float a)
{
  return normcdff(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfcx(float a)
{
  return erfcxf(a);
}

static __inline __declspec(__host__) __declspec(__device__) double copysign(double a, float b)
{
  return copysign(a, (double)b);
}

static __inline __declspec(__host__) __declspec(__device__) float copysign(float a, double b)
{
  return copysignf(a, (float)b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(unsigned int a, unsigned int b)
{
  return umin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(int a, unsigned int b)
{
  return umin((unsigned int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(unsigned int a, int b)
{
  return umin(a, (unsigned int)b);
}

static __inline __declspec(__host__) __declspec(__device__) long long int min(long long int a, long long int b)
{
  return llmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(unsigned long long int a, unsigned long long int b)
{
  return ullmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(long long int a, unsigned long long int b)
{
  return ullmin((unsigned long long int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(unsigned long long int a, long long int b)
{
  return ullmin(a, (unsigned long long int)b);
}

static __inline __declspec(__host__) __declspec(__device__) float min(float a, float b)
{
  return fminf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(double a, double b)
{
  return fmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(float a, double b)
{
  return fmin((double)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(double a, float b)
{
  return fmin(a, (double)b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(unsigned int a, unsigned int b)
{
  return umax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(int a, unsigned int b)
{
  return umax((unsigned int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(unsigned int a, int b)
{
  return umax(a, (unsigned int)b);
}

static __inline __declspec(__host__) __declspec(__device__) long long int max(long long int a, long long int b)
{
  return llmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(unsigned long long int a, unsigned long long int b)
{
  return ullmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(long long int a, unsigned long long int b)
{
  return ullmax((unsigned long long int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(unsigned long long int a, long long int b)
{
  return ullmax(a, (unsigned long long int)b);
}

static __inline __declspec(__host__) __declspec(__device__) float max(float a, float b)
{
  return fmaxf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(double a, double b)
{
  return fmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(float a, double b)
{
  return fmax((double)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(double a, float b)
{
  return fmax(a, (double)b);
}





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 14753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





#line 14759 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"





#line 14765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"



#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions_dbl_ptx3.h"













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 4335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions_dbl_ptx3.h"

#line 4337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions_dbl_ptx3.h"

#line 14769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

#line 14771 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

#line 14773 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\math_functions.h"

#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\common_functions.h"

#line 77 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"



























































































































































































































































































































































































































#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"







template<class T, int dim = 1>
struct __declspec(__device_builtin_surface_type__) surface : public surfaceReference
{
  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __declspec(__host__) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }
};

template<int dim>
struct  __declspec(__device_builtin_surface_type__)  surface<void, dim> : public surfaceReference
{
  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }
};

#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"

#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"
#line 78 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"



























































































































































































































































































































































































































#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\channel_descriptor.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"







template<class T, int texType = 0x01, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct __declspec(__device_builtin_texture_type__) texture : public textureReference
{
  __declspec(__host__) texture(int                         norm  = 0,
                   enum cudaTextureFilterMode  fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = cudaCreateChannelDesc<T>();
    sRGB           = 0;
  }

  __declspec(__host__) texture(int                          norm,
                   enum cudaTextureFilterMode   fMode,
                   enum cudaTextureAddressMode  aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = desc;
    sRGB           = 0;
  }
};

#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"

#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"
#line 79 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"







extern "C"
{









extern __declspec(__device__) __declspec(__device_builtin__) int                    __mulhi(int x, int y);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __umulhi(unsigned int x, unsigned int y);









extern __declspec(__device__) __declspec(__device_builtin__) long long int          __mul64hi(long long int x, long long int y);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __umul64hi(unsigned long long int x, unsigned long long int y);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int_as_float(int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float_as_int(float x);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __syncthreads(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __prof_trigger(int);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence_block(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __trap(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __brkpt(int c = 0);






















extern __declspec(__device__) __declspec(__device_builtin__) float                  __saturatef(float x);




































































extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __sad(int x, int y, unsigned int z);



































































extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __usad(unsigned int x, unsigned int y, unsigned int z);









extern __declspec(__device__) __declspec(__device_builtin__) int                    __mul24(int x, int y);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __umul24(unsigned int x, unsigned int y);












extern __declspec(__device__) __declspec(__device_builtin__) float                  fdividef(float x, float y);










































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdividef(float x, float y);
extern __declspec(__device__) __declspec(__device_builtin__) double                 fdivide(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __sinf(float x) ;











extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __cosf(float x) ;













extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __tanf(float x) ;














extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void                   __sincosf(float x, float *sptr, float *cptr) ;

















































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __expf(float x) ;































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __exp10f(float x) ;

























extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __log2f(float x) ;



























extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __log10f(float x) ;











































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __logf(float x) ;










































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __powf(float x, float y) ;








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_ru(float);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_ru(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_rn(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_rz(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_ru(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_rd(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_rn(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_rz(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_ru(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_rd(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_ru(float x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_ru(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_rn(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_rz(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_ru(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_rd(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_rn(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_rz(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_ru(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_rd(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned short         __float2half_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __half2float(unsigned short x);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_rn(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_rz(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_ru(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_rd(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_rn(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_rz(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_ru(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_rd(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_rn(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_rz(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_ru(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_rd(float x, float y);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_rn(float x, float y, float z);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_rz(float x, float y, float z);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_ru(float x, float y, float z);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_rd(float x, float y, float z);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_rn(float x);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_rz(float x);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_ru(float x);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_rd(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_rn(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_rz(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_ru(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_rd(float x);






































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frsqrt_rn(float x);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_rn(float x, float y);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_rz(float x, float y);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_ru(float x, float y);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_rd(float x, float y);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __clz(int x);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __ffs(int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __popc(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __brev(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __clzll(long long int x);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __ffsll(long long int x);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __popcll(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __brevll(unsigned long long int x);























extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __byte_perm(unsigned int x, unsigned int y, unsigned int s);











extern __declspec(__device__) __declspec(__device_builtin__) int                    __hadd(int, int);












extern __declspec(__device__) __declspec(__device_builtin__) int                    __rhadd(int, int);











extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __uhadd(unsigned int, unsigned int);












extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __urhadd(unsigned int, unsigned int);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2int_rz(double);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __double2uint_rz(double);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rz(double);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rz(double);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm0(void);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm1(void);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm2(void);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm3(void);
#line 2278 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
















extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabs2(unsigned int a);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabsss2(unsigned int a);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vadd2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vaddss2 (unsigned int a, unsigned int b);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vaddus2 (unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vavgs2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vavgu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vhaddu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpeq2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpges2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpgeu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpgts2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpgtu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmples2(unsigned int a, unsigned int b);











extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpleu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmplts2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpltu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpne2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabsdiffu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vmaxs2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vmaxu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vmins2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vminu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vseteq2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetges2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetgeu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetgts2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetgtu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetles2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetleu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetlts2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetltu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetne2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsadu2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsub2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsubss2 (unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsubus2 (unsigned int a, unsigned int b);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vneg2(unsigned int a);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vnegss2(unsigned int a);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabsdiffs2(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsads2(unsigned int a, unsigned int b);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabs4(unsigned int a);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabsss4(unsigned int a);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vadd4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vaddss4 (unsigned int a, unsigned int b);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vaddus4 (unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vavgs4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vavgu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vhaddu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpeq4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpges4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpgeu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpgts4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpgtu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmples4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpleu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmplts4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpltu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vcmpne4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabsdiffu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vmaxs4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vmaxu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vmins4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vminu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vseteq4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetles4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetleu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetlts4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetltu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetges4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetgeu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetgts4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetgtu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsetne4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsadu4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsub4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsubss4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsubus4(unsigned int a, unsigned int b);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vneg4(unsigned int a);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vnegss4(unsigned int a);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vabsdiffs4(unsigned int a, unsigned int b);










extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __vsads4(unsigned int a, unsigned int b);






}







static __inline __declspec(__device__) int mulhi(int a, int b)
{
  return __mulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(unsigned int a, unsigned int b)
{
  return __umulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(int a, unsigned int b)
{
  return __umulhi((unsigned int)a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(unsigned int a, int b)
{
  return __umulhi(a, (unsigned int)b);
}

static __inline __declspec(__device__) long long int mul64hi(long long int a, long long int b)
{
  return __mul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(unsigned long long int a, unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(long long int a, unsigned long long int b)
{
  return __umul64hi((unsigned long long int)a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(unsigned long long int a, long long int b)
{
  return __umul64hi(a, (unsigned long long int)b);
}

static __inline __declspec(__device__) int float_as_int(float a)
{
  return __float_as_int(a);
}

static __inline __declspec(__device__) float int_as_float(int a)
{
  return __int_as_float(a);
}

static __inline __declspec(__device__) float saturate(float a)
{
  return __saturatef(a);
}

static __inline __declspec(__device__) int mul24(int a, int b)
{
  return __mul24(a, b);
}

static __inline __declspec(__device__) unsigned int umul24(unsigned int a, unsigned int b)
{
  return __umul24(a, b);
}

static __inline __declspec(__device__) void trap(void)
{
  __trap();
}


static __inline __declspec(__device__) void brkpt(int c = 0)
{
  __brkpt(c);
}

static __inline __declspec(__device__) void syncthreads(void)
{
  __syncthreads();
}

static __inline __declspec(__device__) void prof_trigger(int e)
{
       if (e ==  0) __prof_trigger( 0);
  else if (e ==  1) __prof_trigger( 1);
  else if (e ==  2) __prof_trigger( 2);
  else if (e ==  3) __prof_trigger( 3);
  else if (e ==  4) __prof_trigger( 4);
  else if (e ==  5) __prof_trigger( 5);
  else if (e ==  6) __prof_trigger( 6);
  else if (e ==  7) __prof_trigger( 7);
  else if (e ==  8) __prof_trigger( 8);
  else if (e ==  9) __prof_trigger( 9);
  else if (e == 10) __prof_trigger(10);
  else if (e == 11) __prof_trigger(11);
  else if (e == 12) __prof_trigger(12);
  else if (e == 13) __prof_trigger(13);
  else if (e == 14) __prof_trigger(14);
  else if (e == 15) __prof_trigger(15);
}

static __inline __declspec(__device__) void threadfence(bool global = true)
{
  global ? __threadfence() : __threadfence_block();
}

static __inline __declspec(__device__) int float2int(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2int_rn(a) :
         mode == cudaRoundPosInf  ? __float2int_ru(a) :
         mode == cudaRoundMinInf  ? __float2int_rd(a) :
                                    __float2int_rz(a);
}

static __inline __declspec(__device__) unsigned int float2uint(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2uint_rn(a) :
         mode == cudaRoundPosInf  ? __float2uint_ru(a) :
         mode == cudaRoundMinInf  ? __float2uint_rd(a) :
                                    __float2uint_rz(a);
}

static __inline __declspec(__device__) float int2float(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __int2float_rz(a) :
         mode == cudaRoundPosInf ? __int2float_ru(a) :
         mode == cudaRoundMinInf ? __int2float_rd(a) :
                                   __int2float_rn(a);
}

static __inline __declspec(__device__) float uint2float(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __uint2float_rz(a) :
         mode == cudaRoundPosInf ? __uint2float_ru(a) :
         mode == cudaRoundMinInf ? __uint2float_rd(a) :
                                   __uint2float_rn(a);
}


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 9398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"







#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_11_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_11_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_11_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicAdd(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicAdd(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicExch(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicExch(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) float        __fAtomicExch(float *address, float val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicMin(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicMin(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicMax(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicMax(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicInc(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicDec(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicAnd(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicAnd(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicOr(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicOr(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicXor(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicXor(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicCAS(int *address, int compare, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val);

}







static __inline __declspec(__device__) int atomicAdd(int *address, int val)
{
  return __iAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAdd(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, val);
}

static __inline __declspec(__device__) int atomicSub(int *address, int val)
{
  return __iAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) unsigned int atomicSub(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) int atomicExch(int *address, int val)
{
  return __iAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned int atomicExch(unsigned int *address, unsigned int val)
{
  return __uAtomicExch(address, val);
}

static __inline __declspec(__device__) float atomicExch(float *address, float val)
{
  return __fAtomicExch(address, val);
}

static __inline __declspec(__device__) int atomicMin(int *address, int val)
{
  return __iAtomicMin(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMin(unsigned int *address, unsigned int val)
{
  return __uAtomicMin(address, val);
}

static __inline __declspec(__device__) int atomicMax(int *address, int val)
{
  return __iAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMax(unsigned int *address, unsigned int val)
{
  return __uAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicInc(unsigned int *address, unsigned int val)
{
  return __uAtomicInc(address, val);
}

static __inline __declspec(__device__) unsigned int atomicDec(unsigned int *address, unsigned int val)
{
  return __uAtomicDec(address, val);
}

static __inline __declspec(__device__) int atomicAnd(int *address, int val)
{
  return __iAtomicAnd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAnd(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd(address, val);
}

static __inline __declspec(__device__) int atomicOr(int *address, int val)
{
  return __iAtomicOr(address, val);
}

static __inline __declspec(__device__) unsigned int atomicOr(unsigned int *address, unsigned int val)
{
  return __uAtomicOr(address, val);
}

static __inline __declspec(__device__) int atomicXor(int *address, int val)
{
  return __iAtomicXor(address, val);
}

static __inline __declspec(__device__) unsigned int atomicXor(unsigned int *address, unsigned int val)
{
  return __uAtomicXor(address, val);
}

static __inline __declspec(__device__) int atomicCAS(int *address, int compare, int val)
{
  return __iAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  return __uAtomicCAS(address, compare, val);
}

#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_11_atomic_functions.h"

#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_11_atomic_functions.h"

#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_11_atomic_functions.h"
#line 9406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_12_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_12_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_12_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicAdd(unsigned long long int *address, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicExch(unsigned long long int *address, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) int                    __any(int cond);
extern __declspec(__device__) __declspec(__device_builtin__) int                    __all(int cond);
}







static __inline __declspec(__device__) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val)
{
  return __ullAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) bool any(bool cond)
{
  return (bool)__any((int)cond);
}

static __inline __declspec(__device__) bool all(bool cond)
{
  return (bool)__all((int)cond);
}

#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_12_atomic_functions.h"

#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_12_atomic_functions.h"

#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_12_atomic_functions.h"
#line 9407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"




































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 72 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"

extern "C"
{








extern __declspec(__device__) __declspec(__device_builtin__) long long int         __double_as_longlong(double x);








extern __declspec(__device__) __declspec(__device_builtin__) double                __longlong_as_double(long long int x);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rn(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rz(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_ru(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rd(double x, double y, double z);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rd(double x, double y);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rz(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rd(double x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __int2double_rn(int x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __uint2double_rn(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rn(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rz(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_ru(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rd(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rn(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rz(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_ru(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rd(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2hiint(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2loint(double x);









extern __declspec(__device__) __declspec(__device_builtin__) double                 __hiloint2double(int hi, int lo);
}







static __inline __declspec(__device__) double fma(double a, double b, double c, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __fma_rz(a, b, c) :
         mode == cudaRoundPosInf ? __fma_ru(a, b, c) :
         mode == cudaRoundMinInf ? __fma_rd(a, b, c) :
                                   __fma_rn(a, b, c);
}

static __inline __declspec(__device__) double dmul(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __dmul_rz(a, b) :
         mode == cudaRoundPosInf ? __dmul_ru(a, b) :
         mode == cudaRoundMinInf ? __dmul_rd(a, b) :
                                   __dmul_rn(a, b);
}

static __inline __declspec(__device__) double dadd(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __dadd_rz(a, b) :
         mode == cudaRoundPosInf ? __dadd_ru(a, b) :
         mode == cudaRoundMinInf ? __dadd_rd(a, b) :
                                   __dadd_rn(a, b);
}

static __inline __declspec(__device__) double dsub(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __dsub_rz(a, b) :
         mode == cudaRoundPosInf ? __dsub_ru(a, b) :
         mode == cudaRoundMinInf ? __dsub_rd(a, b) :
                                   __dsub_rn(a, b);
}

static __inline __declspec(__device__) int double2int(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2int_rn(a) :
         mode == cudaRoundPosInf  ? __double2int_ru(a) :
         mode == cudaRoundMinInf  ? __double2int_rd(a) :
                                    __double2int_rz(a);
}

static __inline __declspec(__device__) unsigned int double2uint(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2uint_rn(a) :
         mode == cudaRoundPosInf  ? __double2uint_ru(a) :
         mode == cudaRoundMinInf  ? __double2uint_rd(a) :
                                    __double2uint_rz(a);
}

static __inline __declspec(__device__) long long int double2ll(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2ll_rn(a) :
         mode == cudaRoundPosInf  ? __double2ll_ru(a) :
         mode == cudaRoundMinInf  ? __double2ll_rd(a) :
                                    __double2ll_rz(a);
}

static __inline __declspec(__device__) unsigned long long int double2ull(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2ull_rn(a) :
         mode == cudaRoundPosInf  ? __double2ull_ru(a) :
         mode == cudaRoundMinInf  ? __double2ull_rd(a) :
                                    __double2ull_rz(a);
}

static __inline __declspec(__device__) double ll2double(long long int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __ll2double_rz(a) :
         mode == cudaRoundPosInf ? __ll2double_ru(a) :
         mode == cudaRoundMinInf ? __ll2double_rd(a) :
                                   __ll2double_rn(a);
}

static __inline __declspec(__device__) double ull2double(unsigned long long int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __ull2double_rz(a) :
         mode == cudaRoundPosInf ? __ull2double_ru(a) :
         mode == cudaRoundMinInf ? __ull2double_rd(a) :
                                   __ull2double_rn(a);
}

static __inline __declspec(__device__) double int2double(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

static __inline __declspec(__device__) double uint2double(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

static __inline __declspec(__device__) double float2double(float a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

#line 1229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"

































#line 1263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"

#line 1265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_13_double_functions.h"

#line 9408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) float __fAtomicAdd(float *address, float val);
}







static __inline __declspec(__device__) float atomicAdd(float *address, float val)
{
  return __fAtomicAdd(address, val);
}

#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_atomic_functions.h"

#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_atomic_functions.h"

#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_atomic_functions.h"
#line 9409 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_atomic_functions.h"





















































































































#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_atomic_functions.h"

#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_atomic_functions.h"

#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_atomic_functions.h"
#line 9410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_35_atomic_functions.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_atomic_functions.h"

























































































































#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_atomic_functions.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_35_atomic_functions.h"

#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_35_atomic_functions.h"
#line 9411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence_system(void);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rd(double x, double y);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rn(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rz(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_ru(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rd(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rn(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rz(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_ru(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rd(double x);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __ballot(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_count(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_and(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_or(int);
extern __declspec(__device__) __declspec(__device_builtin__) long long int         clock64(void);






extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_rn(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_rz(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_ru(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_rd(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) double                __rcp64h(double);

}







static __inline __declspec(__device__) unsigned int ballot(bool pred)
{
  return __ballot((int)pred);
}

static __inline __declspec(__device__) int syncthreads_count(bool pred)
{
  return __syncthreads_count((int)pred);
}

static __inline __declspec(__device__) bool syncthreads_and(bool pred)
{
  return (bool)__syncthreads_and((int)pred);
}

static __inline __declspec(__device__) bool syncthreads_or(bool pred)
{
  return (bool)__syncthreads_or((int)pred);
}




static __inline __declspec(__device__) unsigned int __isGlobal(const void *ptr)
{
    unsigned int ret;
    asm volatile ("{ \n\t"
                  "    .reg .pred p; \n\t"
                  "    isspacep.global p, %1; \n\t"
                  "    selp.u32 %0, 1, 0, p;  \n\t"


#line 440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"
                  "} \n\t" : "=r"(ret) : "r"(ptr));
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"

    return ret;
}

#line 447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"

#line 449 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"

#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_20_intrinsics.h"
#line 9412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_30_intrinsics.h"























































































































































































































































































































#line 313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_30_intrinsics.h"

#line 315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_30_intrinsics.h"

#line 317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_30_intrinsics.h"
#line 9413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_intrinsics.h"





































































































































































#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_intrinsics.h"

#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_intrinsics.h"

#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_intrinsics.h"
#line 9414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_35_intrinsics.h"














































































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_intrinsics.h"









































































































































































#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_32_intrinsics.h"
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_35_intrinsics.h"



#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\sm_35_intrinsics.h"

#line 9415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"

































































































#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_surface_types.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 67 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"






extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf1Dreadc1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf1Dreadc2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf1Dreadc4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf1Dreads1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf1Dreads2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf1Dreads4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf1Dreadu1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf1Dreadu2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf1Dreadu4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf1Dreadl1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf1Dreadl2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);













#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1Dread(T *res, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surf1Dreadc1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc1(surf, x, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surf1Dreads1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads1(surf, x, cudaBoundaryModeClamp) : __surf1Dreads1(surf, x, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu2(surf, x, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu4(surf, x, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf1Dread(&tmp, surf, x, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf1Dread(T *res, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1Dread<T>(surf, x, mode);
}

template<>
__forceinline __declspec(__device__) char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surf1Dreadc1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surf1Dreadc1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadc1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surf1Dreadc1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadc1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc1(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadc2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc2(surf, x, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadc2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc2(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadc4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc4(surf, x, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadc4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadc4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadc4(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surf1Dreads1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads1(surf, x, cudaBoundaryModeClamp) : __surf1Dreads1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreads1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads1(surf, x, cudaBoundaryModeClamp) : __surf1Dreads1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surf1Dreads1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads1(surf, x, cudaBoundaryModeClamp) : __surf1Dreads1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreads1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads1(surf, x, cudaBoundaryModeClamp) : __surf1Dreads1(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreads2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads2(surf, x, cudaBoundaryModeClamp) : __surf1Dreads2(surf, x, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreads2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads2(surf, x, cudaBoundaryModeClamp) : __surf1Dreads2(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreads4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads4(surf, x, cudaBoundaryModeClamp) : __surf1Dreads4(surf, x, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreads4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreads4(surf, x, cudaBoundaryModeClamp) : __surf1Dreads4(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu2(surf, x, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadu2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu2(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu4(surf, x, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadu4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu4(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surf1Dreadl1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadl1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadl1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadl1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadl1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadl1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surf1Dreadl1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadl1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadl1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadl1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadl1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadl1(surf, x, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadl2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadl2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadl2(surf, x, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1Dreadl2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadl2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadl2(surf, x, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu2(surf, x, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu2(surf, x, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu4(surf, x, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu4(surf, x, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf1Dreadu1(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu1(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu1(surf, x, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu2(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu2(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu2(surf, x, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1Dreadu4(surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dreadu4(surf, x, cudaBoundaryModeClamp) : __surf1Dreadu4(surf, x, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf2Dreadc1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf2Dreadc2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf2Dreadc4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf2Dreads1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf2Dreads2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf2Dreads4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf2Dreadu1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf2Dreadu2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf2Dreadu4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf2Dreadl1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf2Dreadl2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);













#line 446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2Dread<T>(surf, x, y, mode);
}

template<>
__forceinline __declspec(__device__) char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadc2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadc2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadc4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadc4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadc4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreads2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreads2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreads4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreads4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreads4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadl1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadl2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadl2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2Dreadl2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadl2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu1(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu2(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dreadu4(surf, x, y, cudaBoundaryModeClamp) : __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf3Dreadc1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf3Dreadc2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf3Dreadc4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf3Dreads1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf3Dreads2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf3Dreads4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf3Dreadu1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf3Dreadu2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf3Dreadu4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf3Dreadl1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf3Dreadl2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);













#line 794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf3Dread<T>(surf, x, y, z, mode);
}

template<>
__forceinline __declspec(__device__) char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreads2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreads2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreads4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreads4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreads4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 1081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf1DLayeredreadc1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf1DLayeredreadc2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf1DLayeredreadc4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf1DLayeredreads1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf1DLayeredreads2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf1DLayeredreads4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf1DLayeredreadu1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf1DLayeredreadu2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf1DLayeredreadu4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf1DLayeredreadl1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf1DLayeredreadl2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);













#line 1142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1DLayeredread<T>(surf, x, layer, mode);
}

template<>
__forceinline __declspec(__device__) char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 1429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf2DLayeredreadc1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf2DLayeredreadc2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf2DLayeredreadc4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf2DLayeredreads1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf2DLayeredreads2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf2DLayeredreads4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf2DLayeredreadu1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf2DLayeredreadu2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf2DLayeredreadu4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf2DLayeredreadl1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf2DLayeredreadl2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);













#line 1490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2DLayeredread<T>(surf, x, y, layer, mode);
}

template<>
__forceinline __declspec(__device__) char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 1777 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surfCubemapreadc1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surfCubemapreadc2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surfCubemapreadc4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surfCubemapreads1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surfCubemapreads2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surfCubemapreads4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surfCubemapreadu1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surfCubemapreadu2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surfCubemapreadu4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surfCubemapreadl1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surfCubemapreadl2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);













#line 1838 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surfCubemapread<T>(surf, x, y, face, mode);
}

template<>
__forceinline __declspec(__device__) char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 2125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surfCubemapLayeredreadc1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surfCubemapLayeredreadc2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surfCubemapLayeredreadc4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surfCubemapLayeredreads1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surfCubemapLayeredreads2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surfCubemapLayeredreads4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surfCubemapLayeredreadu1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surfCubemapLayeredreadu2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surfCubemapLayeredreadu4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surfCubemapLayeredreadl1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surfCubemapLayeredreadl2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);














#line 2187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(*(ushort1*)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(*(uint1  *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(*(uint2  *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(*(uint4  *)res = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surfCubemapLayeredread<T>(surf, x, y, layerFace, mode);
}

template<>
__forceinline __declspec(__device__) char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (char)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) signed char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) char1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) char4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (short)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) short1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) short4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) int1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) uint1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) int4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) long long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

template<>
__forceinline __declspec(__device__) longlong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
}



template<>
__forceinline __declspec(__device__) long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x;
}

template<>
__forceinline __declspec(__device__) long1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) long2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 2474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x);
}

template<>
__forceinline __declspec(__device__) float1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap )).x));
}

template<>
__forceinline __declspec(__device__) float2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap ));
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritec1(    uchar1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritec2(    uchar2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritec4(    uchar4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwrites1(   ushort1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwrites2(   ushort2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwrites4(   ushort4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwriteu1(     uint1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwriteu2(     uint2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwriteu4(     uint4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritel1(ulonglong1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritel2(ulonglong2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);













#line 2536 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeClamp) : __surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeClamp) : __surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1Dwrite(val, surf, x, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf1Dwrite(char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(signed char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeClamp) : __surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(char1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec1(make_uchar1((unsigned char)val.x), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec1(make_uchar1((unsigned char)val.x), surf, x, cudaBoundaryModeClamp) : __surf1Dwritec1(make_uchar1((unsigned char)val.x), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec1(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec1(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(char2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, cudaBoundaryModeClamp) : __surf1Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec2(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec2(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(char4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, cudaBoundaryModeClamp) : __surf1Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritec4(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritec4(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(short val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned short val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeClamp) : __surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(short1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites1(make_ushort1((unsigned short)val.x), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites1(make_ushort1((unsigned short)val.x), surf, x, cudaBoundaryModeClamp) : __surf1Dwrites1(make_ushort1((unsigned short)val.x), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites1(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites1(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(short2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, cudaBoundaryModeClamp) : __surf1Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites2(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites2(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(short4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, cudaBoundaryModeClamp) : __surf1Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwrites4(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwrites4(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(int1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(int2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu2(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu2(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(int4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu4(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu4(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(long long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned long long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeClamp) : __surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, cudaBoundaryModeClamp) : __surf1Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritel1(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritel1(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, cudaBoundaryModeClamp) : __surf1Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwritel2(val, surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwritel2(val, surf, x, cudaBoundaryModeClamp) : __surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surf1Dwrite(long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(long1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(long2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(long4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulong4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap ));
}

#line 2764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf1Dwrite(float val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(float1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(float2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1Dwrite(float4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, cudaBoundaryModeClamp) : __surf1Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap ));
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritec1(    uchar1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritec2(    uchar2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritec4(    uchar4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwrites1(   ushort1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwrites2(   ushort2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwrites4(   ushort4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwriteu1(     uint1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwriteu2(     uint2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwriteu4(     uint4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritel1(ulonglong1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritel2(ulonglong2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);













#line 2818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf2Dwrite(char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(signed char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(char1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec1(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec1(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(char2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec2(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec2(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(char4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritec4(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritec4(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(short val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned short val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(short1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites1(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites1(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(short2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites2(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites2(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(short4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwrites4(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwrites4(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(int1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(int2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(int4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(long long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned long long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritel1(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritel1(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwritel2(val, surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwritel2(val, surf, x, y, cudaBoundaryModeClamp) : __surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surf2Dwrite(long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(long1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(long2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(long4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulong4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap ));
}

#line 3046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf2Dwrite(float val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(float1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(float2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2Dwrite(float4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeClamp) : __surf2Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap ));
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritec1(    uchar1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritec2(    uchar2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritec4(    uchar4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwrites1(   ushort1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwrites2(   ushort2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwrites4(   ushort4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwriteu1(     uint1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwriteu2(     uint2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwriteu4(     uint4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritel1(ulonglong1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritel2(ulonglong2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);













#line 3100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf3Dwrite(char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(signed char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(char1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(char2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(char4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(short val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned short val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(short1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(short2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(short4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(int1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(int2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(int4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(long long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned long long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surf3Dwrite(long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(long1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(long2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(long4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulong4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap ));
}

#line 3328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf3Dwrite(float val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(float1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(float2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, z, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf3Dwrite(float4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf3Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf3Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeClamp) : __surf3Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap ));
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritec1(    uchar1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritec2(    uchar2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritec4(    uchar4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwrites1(   ushort1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwrites2(   ushort2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwrites4(   ushort4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwriteu1(     uint1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwriteu2(     uint2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwriteu4(     uint4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritel1(ulonglong1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritel2(ulonglong2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);













#line 3382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf1DLayeredwrite(char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(signed char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned short val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned long long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surf1DLayeredwrite(long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulong4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap ));
}

#line 3610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf1DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeClamp) : __surf1DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap ));
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritec1(    uchar1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritec2(    uchar2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritec4(    uchar4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwrites1(   ushort1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwrites2(   ushort2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwrites4(   ushort4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwriteu1(     uint1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwriteu2(     uint2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwriteu4(     uint4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritel1(ulonglong1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritel2(ulonglong2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);













#line 3664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf2DLayeredwrite(char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(signed char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned short val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned long long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surf2DLayeredwrite(long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulong4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap ));
}

#line 3892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layer, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surf2DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeClamp) : __surf2DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap ));
}








extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritec1(    uchar1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritec2(    uchar2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritec4(    uchar4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwrites1(   ushort1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwrites2(   ushort2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwrites4(   ushort4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwriteu1(     uint1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwriteu2(     uint2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwriteu4(     uint4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritel1(ulonglong1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritel2(ulonglong2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);














#line 3946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surfCubemapwrite(char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(signed char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec1(make_uchar1((unsigned char)val.x), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec1(make_uchar1((unsigned char)val.x), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec1(make_uchar1((unsigned char)val.x), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned short val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites1(make_ushort1((unsigned short)val.x), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites1(make_ushort1((unsigned short)val.x), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites1(make_ushort1((unsigned short)val.x), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned long long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surfCubemapwrite(long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulong4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap ));
}

#line 4174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surfCubemapwrite(float val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, face, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeClamp) : __surfCubemapwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap ));
}








extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritec1(    uchar1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritec2(    uchar2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritec4(    uchar4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwrites1(   ushort1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwrites2(   ushort2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwrites4(   ushort4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwriteu1(     uint1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwriteu2(     uint2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwriteu4(     uint4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritel1(ulonglong1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritel2(ulonglong2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);














#line 4228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s ==  2) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s ==  4) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s ==  8) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
  (s == 16) ? (void)(((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap ))) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(signed char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned short val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned long long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap ));
}



static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulong4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

#line 4456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  ((mode == cudaBoundaryModeZero) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeZero ) : (mode == cudaBoundaryModeClamp) ? __surfCubemapLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeClamp) : __surfCubemapLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap ));
}


























































































































































































































































































#line 4759 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

#line 4761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_functions.h"

#line 9416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"









































































































#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\cuda_texture_types.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 67 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlc(texture<T, texType, readMode> t, float4 i, int l);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlc(texture<T, texType, readMode> t, float4 i, int l);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlc(texture<T, texType, readMode> t, float4 i, int l);







static __forceinline __declspec(__device__) char tex1Dfetch(texture<char, 0x01, cudaReadModeElementType> t, int x)
{


#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchi(t, make_int4(x, 0, 0, 0));
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1Dfetch(texture<signed char, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1Dfetch(texture<unsigned char, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1Dfetch(texture<char1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1Dfetch(texture<uchar1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1Dfetch(texture<char2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1Dfetch(texture<uchar2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1Dfetch(texture<char4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1Dfetch(texture<uchar4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1Dfetch(texture<short, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1Dfetch(texture<unsigned short, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1Dfetch(texture<short1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1Dfetch(texture<ushort1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1Dfetch(texture<short2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1Dfetch(texture<ushort2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1Dfetch(texture<short4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1Dfetch(texture<ushort4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1Dfetch(texture<int, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1Dfetch(texture<unsigned int, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1Dfetch(texture<int1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1Dfetch(texture<uint1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1Dfetch(texture<int2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1Dfetch(texture<uint2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1Dfetch(texture<int4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1Dfetch(texture<uint4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1Dfetch(texture<long, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1Dfetch(texture<unsigned long, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1Dfetch(texture<long1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1Dfetch(texture<ulong1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1Dfetch(texture<long2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1Dfetch(texture<ulong2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1Dfetch(texture<long4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1Dfetch(texture<ulong4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1Dfetch(texture<float, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<float1, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<float2, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<float4, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1Dfetch(texture<char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{


#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1Dfetch(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1Dfetch(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1Dfetch(texture<short, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1Dfetch(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v   = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1D(texture<char, 0x01, cudaReadModeElementType> t, float x)
{


#line 550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetch(t, make_float4(x, 0, 0, 0));
#line 552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1D(texture<signed char, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1D(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1D(texture<char1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1D(texture<uchar1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1D(texture<char2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1D(texture<uchar2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1D(texture<char4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1D(texture<uchar4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1D(texture<short, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1D(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1D(texture<short1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1D(texture<ushort1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1D(texture<short2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1D(texture<ushort2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1D(texture<short4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1D(texture<ushort4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1D(texture<int, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1D(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1D(texture<int1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1D(texture<uint1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1D(texture<int2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1D(texture<uint2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1D(texture<int4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1D(texture<uint4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}















static __forceinline __declspec(__device__) long tex1D(texture<long, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1D(texture<unsigned long, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1D(texture<long1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1D(texture<ulong1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1D(texture<long2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1D(texture<ulong2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1D(texture<long4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1D(texture<ulong4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1D(texture<float, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1D(texture<float1, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<float2, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<float4, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1D(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{


#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
#line 855 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1D(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1D(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1D(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1D(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1D(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1D(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1D(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1D(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v   = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2D(texture<char, 0x02, cudaReadModeElementType> t, float x, float y)
{


#line 1005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetch(t, make_float4(x, y, 0, 0));
#line 1007 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2D(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2D(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2D(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2D(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2D(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2D(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2D(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2D(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2D(texture<short, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2D(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2D(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2D(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2D(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2D(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2D(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2D(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2D(texture<int, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2D(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2D(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2D(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2D(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2D(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2D(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2D(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2D(texture<long, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2D(texture<unsigned long, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2D(texture<long1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2D(texture<ulong1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2D(texture<long2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2D(texture<ulong2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2D(texture<long4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2D(texture<ulong4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 1256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2D(texture<float, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2D(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2D(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{


#line 1302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2D(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2D(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2D(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2D(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2D(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2D(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2D(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2D(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v   = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1DLayered(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{


#line 1454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
#line 1456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLayered(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLayered(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLayered(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLayered(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLayered(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLayered(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLayered(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLayered(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLayered(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLayered(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLayered(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLayered(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLayered(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLayered(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLayered(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLayered(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLayered(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLayered(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLayered(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLayered(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLayered(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLayered(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLayered(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLayered(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1DLayered(texture<long, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLayered(texture<unsigned long, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLayered(texture<long1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLayered(texture<ulong1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLayered(texture<long2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLayered(texture<ulong2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLayered(texture<long4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLayered(texture<ulong4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 1705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLayered(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLayered(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{


#line 1751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
#line 1753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayered(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayered(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLayered(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayered(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v   = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLayered(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{


#line 1903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
#line 1905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLayered(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLayered(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLayered(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLayered(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLayered(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLayered(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLayered(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLayered(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLayered(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLayered(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLayered(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLayered(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLayered(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLayered(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLayered(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLayered(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLayered(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLayered(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLayered(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLayered(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLayered(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLayered(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLayered(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLayered(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLayered(texture<long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLayered(texture<unsigned long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLayered(texture<long1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLayered(texture<ulong1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLayered(texture<long2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLayered(texture<ulong2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLayered(texture<long4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLayered(texture<ulong4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 2154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLayered(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLayered(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{


#line 2200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
#line 2202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayered(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayered(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLayered(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayered(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v   = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex3D(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{


#line 2352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetch(t, make_float4(x, y, z, 0));
#line 2354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex3D(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex3D(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex3D(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex3D(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex3D(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex3D(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex3D(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex3D(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex3D(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex3D(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex3D(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex3D(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex3D(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex3D(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex3D(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex3D(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex3D(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex3D(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex3D(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex3D(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex3D(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex3D(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex3D(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex3D(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex3D(texture<long, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex3D(texture<unsigned long, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex3D(texture<long1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex3D(texture<ulong1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex3D(texture<long2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex3D(texture<ulong2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex3D(texture<long4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex3D(texture<ulong4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 2603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex3D(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex3D(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex3D(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{


#line 2649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
#line 2651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3D(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3D(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3D(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3D(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex3D(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3D(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3D(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3D(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v   = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemap(texture<char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{


#line 2801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchc(t, make_float4(x, y, z, 0));
#line 2803 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemap(texture<signed char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemap(texture<unsigned char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemap(texture<char1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemap(texture<uchar1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemap(texture<char2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemap(texture<uchar2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemap(texture<char4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemap(texture<uchar4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemap(texture<short, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemap(texture<unsigned short, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemap(texture<short1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemap(texture<ushort1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemap(texture<short2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemap(texture<ushort2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemap(texture<short4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemap(texture<ushort4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemap(texture<int, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemap(texture<unsigned int, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemap(texture<int1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemap(texture<uint1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemap(texture<int2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemap(texture<uint2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemap(texture<int4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemap(texture<uint4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemap(texture<long, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemap(texture<unsigned long, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemap(texture<long1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemap(texture<ulong1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemap(texture<long2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemap(texture<ulong2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemap(texture<long4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemap(texture<ulong4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 3052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemap(texture<float, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<float1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<float2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<float4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemap(texture<char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{


#line 3098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
#line 3100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemap(texture<signed char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemap(texture<unsigned char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<char1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<uchar1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<char2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<uchar2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<char4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<uchar4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemap(texture<short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemap(texture<unsigned short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<short1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<ushort1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<short2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<ushort2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<short4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<ushort4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v   = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemapLayered(texture<char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{


#line 3250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
#line 3252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemapLayered(texture<signed char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemapLayered(texture<unsigned char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemapLayered(texture<char1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemapLayered(texture<uchar1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemapLayered(texture<char2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemapLayered(texture<uchar2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemapLayered(texture<char4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemapLayered(texture<uchar4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemapLayered(texture<short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemapLayered(texture<unsigned short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemapLayered(texture<short1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemapLayered(texture<ushort1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemapLayered(texture<short2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemapLayered(texture<ushort2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemapLayered(texture<short4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemapLayered(texture<ushort4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemapLayered(texture<int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemapLayered(texture<unsigned int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemapLayered(texture<int1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemapLayered(texture<uint1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemapLayered(texture<int2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemapLayered(texture<uint2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemapLayered(texture<int4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemapLayered(texture<uint4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemapLayered(texture<long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemapLayered(texture<unsigned long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemapLayered(texture<long1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemapLayered(texture<ulong1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemapLayered(texture<long2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemapLayered(texture<ulong2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemapLayered(texture<long4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemapLayered(texture<ulong4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 3501 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemapLayered(texture<float, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<float1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<float2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<float4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemapLayered(texture<char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{


#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
#line 3549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayered(texture<signed char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayered(texture<unsigned char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<char1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<uchar1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<char2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<uchar2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<char4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<uchar4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemapLayered(texture<short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayered(texture<unsigned short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<short1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<ushort1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<short2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<ushort2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<short4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<ushort4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v   = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}






















































































#line 3774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"











template<int comp, class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
template<int comp, class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
template<int comp, class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);



















static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<signed short, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<signed int, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { float4 v = __ftex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { float4 v = __ftex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { float4 v = __ftex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}








static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<signed short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}







template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);







static __forceinline __declspec(__device__) char tex1DLod(texture<char, 0x01, cudaReadModeElementType> t, float x, float level)
{


#line 4129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
#line 4131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLod(texture<signed char, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLod(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLod(texture<char1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLod(texture<uchar1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLod(texture<char2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLod(texture<uchar2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLod(texture<char4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLod(texture<uchar4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLod(texture<short, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLod(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLod(texture<short1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLod(texture<ushort1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLod(texture<short2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLod(texture<ushort2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLod(texture<short4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLod(texture<ushort4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLod(texture<int, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLod(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLod(texture<int1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLod(texture<uint1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLod(texture<int2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLod(texture<uint2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLod(texture<int4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLod(texture<uint4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}















static __forceinline __declspec(__device__) long tex1DLod(texture<long, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLod(texture<unsigned long, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLod(texture<long1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLod(texture<ulong1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLod(texture<long2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLod(texture<ulong2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLod(texture<long4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLod(texture<ulong4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 4386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLod(texture<float, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<float1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<float2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<float4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLod(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{


#line 4432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
#line 4434 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLod(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLod(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLod(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLod(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v   = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLod(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{


#line 4584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
#line 4586 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLod(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLod(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLod(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLod(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLod(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLod(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLod(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLod(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLod(texture<short, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLod(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLod(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLod(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLod(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLod(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLod(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLod(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLod(texture<int, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLod(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLod(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLod(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLod(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLod(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLod(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLod(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLod(texture<long, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLod(texture<unsigned long, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLod(texture<long1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLod(texture<ulong1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLod(texture<long2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLod(texture<ulong2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLod(texture<long4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLod(texture<ulong4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 4835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLod(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLod(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{


#line 4881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
#line 4883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLod(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLod(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLod(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLod(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v   = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1DLayeredLod(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{


#line 5033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
#line 5035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLayeredLod(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLayeredLod(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLayeredLod(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLayeredLod(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLayeredLod(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLayeredLod(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLayeredLod(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLayeredLod(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLayeredLod(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLayeredLod(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLayeredLod(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLayeredLod(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLayeredLod(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLayeredLod(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLayeredLod(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLayeredLod(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLayeredLod(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLayeredLod(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLayeredLod(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLayeredLod(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLayeredLod(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLayeredLod(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLayeredLod(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLayeredLod(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1DLayeredLod(texture<long, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLayeredLod(texture<unsigned long, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLayeredLod(texture<long1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLayeredLod(texture<ulong1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLayeredLod(texture<long2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLayeredLod(texture<ulong2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLayeredLod(texture<long4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLayeredLod(texture<ulong4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 5284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{


#line 5330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
#line 5332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v   = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLayeredLod(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{


#line 5482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
#line 5484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLayeredLod(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLayeredLod(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLayeredLod(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLayeredLod(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLayeredLod(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLayeredLod(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLayeredLod(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLayeredLod(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLayeredLod(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLayeredLod(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLayeredLod(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLayeredLod(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLayeredLod(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLayeredLod(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLayeredLod(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLayeredLod(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLayeredLod(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLayeredLod(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLayeredLod(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLayeredLod(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLayeredLod(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLayeredLod(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLayeredLod(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLayeredLod(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLayeredLod(texture<long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLayeredLod(texture<unsigned long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLayeredLod(texture<long1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLayeredLod(texture<ulong1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLayeredLod(texture<long2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLayeredLod(texture<ulong2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLayeredLod(texture<long4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLayeredLod(texture<ulong4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 5733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{


#line 5779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v   = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex3DLod(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{


#line 5931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlod(t, make_float4(x, y, z, 0), level);
#line 5933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex3DLod(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex3DLod(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex3DLod(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex3DLod(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex3DLod(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex3DLod(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex3DLod(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex3DLod(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex3DLod(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex3DLod(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex3DLod(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex3DLod(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex3DLod(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex3DLod(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex3DLod(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex3DLod(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex3DLod(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex3DLod(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex3DLod(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex3DLod(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex3DLod(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex3DLod(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex3DLod(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex3DLod(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex3DLod(texture<long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex3DLod(texture<unsigned long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex3DLod(texture<long1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex3DLod(texture<ulong1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex3DLod(texture<long2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex3DLod(texture<ulong2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex3DLod(texture<long4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex3DLod(texture<ulong4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 6182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex3DLod(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex3DLod(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{


#line 6228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
#line 6230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DLod(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DLod(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex3DLod(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DLod(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v   = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemapLod(texture<char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{


#line 6380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
#line 6382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemapLod(texture<signed char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemapLod(texture<unsigned char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemapLod(texture<char1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemapLod(texture<uchar1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemapLod(texture<char2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemapLod(texture<uchar2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemapLod(texture<char4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemapLod(texture<uchar4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemapLod(texture<short, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemapLod(texture<unsigned short, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemapLod(texture<short1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemapLod(texture<ushort1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemapLod(texture<short2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemapLod(texture<ushort2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemapLod(texture<short4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemapLod(texture<ushort4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemapLod(texture<int, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemapLod(texture<unsigned int, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemapLod(texture<int1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemapLod(texture<uint1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemapLod(texture<int2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemapLod(texture<uint2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemapLod(texture<int4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemapLod(texture<uint4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemapLod(texture<long, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemapLod(texture<unsigned long, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemapLod(texture<long1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemapLod(texture<ulong1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemapLod(texture<long2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemapLod(texture<ulong2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemapLod(texture<long4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemapLod(texture<ulong4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 6631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemapLod(texture<float, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<float1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<float2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<float4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemapLod(texture<char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{


#line 6677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
#line 6679 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLod(texture<signed char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLod(texture<unsigned char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<char1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<uchar1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<char2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<uchar2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<char4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<uchar4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemapLod(texture<short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLod(texture<unsigned short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<short1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<ushort1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<short2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<ushort2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<short4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<ushort4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v   = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemapLayeredLod(texture<char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{


#line 6829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
#line 6831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemapLayeredLod(texture<signed char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemapLayeredLod(texture<unsigned char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemapLayeredLod(texture<char1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemapLayeredLod(texture<uchar1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemapLayeredLod(texture<char2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemapLayeredLod(texture<uchar2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemapLayeredLod(texture<char4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemapLayeredLod(texture<uchar4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemapLayeredLod(texture<short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemapLayeredLod(texture<unsigned short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemapLayeredLod(texture<short1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemapLayeredLod(texture<ushort1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemapLayeredLod(texture<short2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemapLayeredLod(texture<ushort2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemapLayeredLod(texture<short4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemapLayeredLod(texture<ushort4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemapLayeredLod(texture<int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemapLayeredLod(texture<unsigned int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemapLayeredLod(texture<int1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemapLayeredLod(texture<uint1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemapLayeredLod(texture<int2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemapLayeredLod(texture<uint2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemapLayeredLod(texture<int4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemapLayeredLod(texture<uint4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemapLayeredLod(texture<long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemapLayeredLod(texture<unsigned long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemapLayeredLod(texture<long1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemapLayeredLod(texture<ulong1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemapLayeredLod(texture<long2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemapLayeredLod(texture<ulong2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemapLayeredLod(texture<long4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemapLayeredLod(texture<ulong4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 7080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<float, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<float1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<float2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<float4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{


#line 7126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
#line 7128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<signed char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<unsigned char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<char1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<uchar1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<char2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<uchar2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<char4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<uchar4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<unsigned short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<short1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<ushort1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<short2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<ushort2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<short4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<ushort4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v   = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}


template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));







static __forceinline __declspec(__device__) char tex1DGrad(texture<char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{


#line 7286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 7288 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DGrad(texture<signed char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DGrad(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DGrad(texture<char1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DGrad(texture<uchar1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DGrad(texture<char2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DGrad(texture<uchar2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DGrad(texture<char4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DGrad(texture<uchar4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DGrad(texture<short, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DGrad(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DGrad(texture<short1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DGrad(texture<ushort1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DGrad(texture<short2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DGrad(texture<ushort2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DGrad(texture<short4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DGrad(texture<ushort4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DGrad(texture<int, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DGrad(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DGrad(texture<int1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DGrad(texture<uint1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DGrad(texture<int2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DGrad(texture<uint2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DGrad(texture<int4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DGrad(texture<uint4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}















static __forceinline __declspec(__device__) long tex1DGrad(texture<long, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DGrad(texture<unsigned long, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DGrad(texture<long1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DGrad(texture<ulong1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DGrad(texture<long2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DGrad(texture<ulong2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DGrad(texture<long4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DGrad(texture<ulong4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 7543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DGrad(texture<float, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<float1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<float2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<float4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DGrad(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{


#line 7589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 7591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DGrad(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DGrad(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DGrad(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DGrad(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v   = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DGrad(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{


#line 7741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 7743 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DGrad(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DGrad(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DGrad(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DGrad(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DGrad(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DGrad(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DGrad(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DGrad(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DGrad(texture<short, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DGrad(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DGrad(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DGrad(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DGrad(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DGrad(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DGrad(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DGrad(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DGrad(texture<int, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DGrad(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DGrad(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DGrad(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DGrad(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DGrad(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DGrad(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DGrad(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DGrad(texture<long, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DGrad(texture<unsigned long, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DGrad(texture<long1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DGrad(texture<ulong1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DGrad(texture<long2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DGrad(texture<ulong2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DGrad(texture<long4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DGrad(texture<ulong4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 7992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DGrad(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DGrad(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{


#line 8038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 8040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DGrad(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DGrad(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DGrad(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DGrad(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v   = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1DLayeredGrad(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{


#line 8190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 8192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLayeredGrad(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLayeredGrad(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLayeredGrad(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLayeredGrad(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLayeredGrad(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLayeredGrad(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLayeredGrad(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLayeredGrad(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLayeredGrad(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLayeredGrad(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLayeredGrad(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLayeredGrad(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLayeredGrad(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLayeredGrad(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLayeredGrad(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLayeredGrad(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLayeredGrad(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLayeredGrad(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLayeredGrad(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLayeredGrad(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLayeredGrad(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLayeredGrad(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLayeredGrad(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLayeredGrad(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1DLayeredGrad(texture<long, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLayeredGrad(texture<unsigned long, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLayeredGrad(texture<long1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLayeredGrad(texture<ulong1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLayeredGrad(texture<long2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLayeredGrad(texture<ulong2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLayeredGrad(texture<long4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLayeredGrad(texture<ulong4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 8441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{


#line 8487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 8489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v   = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLayeredGrad(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{


#line 8639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 8641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLayeredGrad(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLayeredGrad(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLayeredGrad(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLayeredGrad(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLayeredGrad(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLayeredGrad(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLayeredGrad(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLayeredGrad(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLayeredGrad(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLayeredGrad(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLayeredGrad(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLayeredGrad(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLayeredGrad(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLayeredGrad(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLayeredGrad(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLayeredGrad(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLayeredGrad(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLayeredGrad(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLayeredGrad(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLayeredGrad(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLayeredGrad(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLayeredGrad(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLayeredGrad(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLayeredGrad(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLayeredGrad(texture<long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLayeredGrad(texture<unsigned long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLayeredGrad(texture<long1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLayeredGrad(texture<ulong1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLayeredGrad(texture<long2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLayeredGrad(texture<ulong2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLayeredGrad(texture<long4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLayeredGrad(texture<ulong4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 8890 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{


#line 8936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 8938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v   = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex3DGrad(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{


#line 9088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
#line 9090 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex3DGrad(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex3DGrad(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex3DGrad(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex3DGrad(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex3DGrad(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex3DGrad(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex3DGrad(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex3DGrad(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex3DGrad(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex3DGrad(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex3DGrad(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex3DGrad(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex3DGrad(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex3DGrad(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex3DGrad(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex3DGrad(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex3DGrad(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex3DGrad(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex3DGrad(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex3DGrad(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex3DGrad(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex3DGrad(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex3DGrad(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex3DGrad(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex3DGrad(texture<long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex3DGrad(texture<unsigned long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex3DGrad(texture<long1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex3DGrad(texture<ulong1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex3DGrad(texture<long2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex3DGrad(texture<ulong2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex3DGrad(texture<long4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex3DGrad(texture<ulong4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 9339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex3DGrad(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex3DGrad(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{


#line 9385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
#line 9387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DGrad(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DGrad(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex3DGrad(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DGrad(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v   = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

#line 9527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"



















































































































#line 9643 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"

#line 9645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_fetch_functions.h"


#line 9417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x)
{



#line 76 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned int *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1Dfetch(long *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(long1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(long2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(long4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned long *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ulong1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ulong2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ulong4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1Dfetch(cudaTextureObject_t texObject, int x)
{
   T ret;
   tex1Dfetch(&ret, texObject, x);
   return ret;
}







static __forceinline __declspec(__device__) void tex1D(char *retVal, cudaTextureObject_t texObject, float x)
{



#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1D(short *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1D(int *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned int *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1D(long *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(long1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(long2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(long4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned long *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ulong1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ulong2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(ulong4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 638 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1D(float *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1D(cudaTextureObject_t texObject, float x)
{
   T ret;
   tex1D(&ret, texObject, x);
   return ret;
}







static __forceinline __declspec(__device__) void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y)
{



#line 700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
#line 703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2D(long *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(long1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(long2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(long4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 950 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2D(cudaTextureObject_t texObject, float x, float y)
{
   T ret;
   tex2D(&ret, texObject, x, y);
   return ret;
}







static __forceinline __declspec(__device__) void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{



#line 1012 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
#line 1015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex3D(long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 1262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex3D(cudaTextureObject_t texObject, float x, float y, float z)
{
   T ret;
   tex3D(&ret, texObject, x, y, z);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer)
{



#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
#line 1327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLayered(long *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 1574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLayered(cudaTextureObject_t texObject, float x, int layer)
{
   T ret;
   tex1DLayered(&ret, texObject, x, layer);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{



#line 1636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
#line 1639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 1886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer)
{
   T ret;
   tex2DLayered(&ret, texObject, x, y, layer);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{



#line 1948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemap(long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 2198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemap(cudaTextureObject_t texObject, float x, float y, float z)
{
   T ret;
   texCubemap(&ret, texObject, x, y, z);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{



#line 2260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemapLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 2510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   T ret;
   texCubemapLayered(&ret, texObject, x, y, z, layer);
   return ret;
}







static __forceinline __declspec(__device__) void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0)
{
   T ret;
   tex2Dgather(&ret, to, x, y, comp);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level)
{



#line 3282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
#line 3285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLod(long *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 3532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLod(cudaTextureObject_t texObject, float x, float level)
{
   T ret;
   tex1DLod(&ret, texObject, x, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{



#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
#line 3597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 3844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level)
{
   T ret;
   tex2DLod(&ret, texObject, x, y, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{



#line 3906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
#line 3909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex3DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 4156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   T ret;
   tex3DLod(&ret, texObject, x, y, z, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{



#line 4218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
#line 4221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 4468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{
   T ret;
   tex1DLayeredLod(&ret, texObject, x, layer, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{



#line 4530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 4780 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   T ret;
   tex2DLayeredLod(&ret, texObject, x, y, layer, level);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{



#line 4842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
#line 4845 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemapLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 5092 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   T ret;
   texCubemapLod(&ret, texObject, x, y, z, level);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{



#line 5154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
#line 5157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemapLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 5404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   T ret;
   texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{



#line 5466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
#line 5469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DGrad(long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 5716 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   T ret;
   tex1DGrad(&ret, texObject, x, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{



#line 5778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   T ret;
   tex2DGrad(&ret, texObject, x, y, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{



#line 6090 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
#line 6093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex3DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6340 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   T ret;
   tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{



#line 6402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
#line 6405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   T ret;
   tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{



#line 6714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
#line 6717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6964 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   T ret;
   tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy);
   return ret;
}

#line 7015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"

#line 7017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"

#line 7019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_indirect_functions.h"



#line 9418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\builtin_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"












































































































































































































#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\host_defines.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_functions.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"








static __forceinline __declspec(__device__) void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf1Dread(&ret, surfObject, x, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf2Dread(&ret, surfObject, x, y, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf3Dread(&ret, surfObject, x, y, z, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surfCubemapread(&ret, surfObject, face, x, y, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surfCubemapLayeredread(&ret, surfObject, x, y, z, layerface, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}

#line 7275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"

#line 7277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"

#line 7279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\surface_indirect_functions.h"



#line 9419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"

#line 9421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_functions.h"

#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\vector_types.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"






#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"


extern "C" {
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"

uint3 __declspec(__device_builtin__) extern const threadIdx;
uint3 __declspec(__device_builtin__) extern const blockIdx;
dim3 __declspec(__device_builtin__) extern const blockDim;
dim3 __declspec(__device_builtin__) extern const gridDim;
int __declspec(__device_builtin__) extern const warpSize;




}
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"






#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"






#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"






#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"






#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"






#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"

#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.5\\include\\device_launch_parameters.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"

#line 83 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"









namespace
{





























template<class T>
__inline __declspec(__host__) cudaError_t cudaSetupArgument(
  T      arg,
  size_t offset
)
{
  return ::cudaSetupArgument((const void*)&arg, sizeof(T), offset);
}































static __inline __declspec(__host__) cudaError_t cudaEventCreate(
  cudaEvent_t  *event,
  unsigned int  flags
)
{
  return ::cudaEventCreateWithFlags(event, flags);
}
























































__inline __declspec(__host__) cudaError_t cudaMallocHost(
  void         **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return ::cudaHostAlloc(ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaHostAlloc(
  T            **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return ::cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaHostGetDevicePointer(
  T            **pDevice,
  void          *pHost,
  unsigned int   flags
)
{
  return ::cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}






































































template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocManaged(
  T            **devPtr,
  size_t         size,
  unsigned int   flags = 0x01
)
{
  return ::cudaMallocManaged((void**)(void*)devPtr, size, flags);
}



































































template<class T>
__inline __declspec(__host__) cudaError_t cudaStreamAttachMemAsync(
  cudaStream_t   stream,
  T              *devPtr,
  size_t         length = 0,
  unsigned int   flags  = 0x04
)
{
  return ::cudaStreamAttachMemAsync(stream, (void*)devPtr, length, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMalloc(
  T      **devPtr,
  size_t   size
)
{
  return ::cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocHost(
  T            **ptr,
  size_t         size,
  unsigned int   flags = 0
)
{
  return cudaMallocHost((void**)(void*)ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocPitch(
  T      **devPtr,
  size_t  *pitch,
  size_t   width,
  size_t   height
)
{
  return ::cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}




































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyToSymbol(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice
)
{
  return ::cudaMemcpyToSymbol((const void*)&symbol, src, count, offset, kind);
}









































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyToSymbolAsync(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice,
        cudaStream_t         stream = 0
)
{
  return ::cudaMemcpyToSymbolAsync((const void*)&symbol, src, count, offset, kind, stream);
}


































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbol(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost
)
{
  return ::cudaMemcpyFromSymbol(dst, (const void*)&symbol, count, offset, kind);
}









































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbolAsync(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost,
        cudaStream_t         stream = 0
)
{
  return ::cudaMemcpyFromSymbolAsync(dst, (const void*)&symbol, count, offset, kind, stream);
}





















template<class T>
__inline __declspec(__host__) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T     &symbol
)
{
  return ::cudaGetSymbolAddress(devPtr, (const void*)&symbol);
}





















template<class T>
__inline __declspec(__host__) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T      &symbol
)
{
  return ::cudaGetSymbolSize(size, (const void*)&symbol);
}



































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
        size_t                            size = 0xffffffff
)
{
  return ::cudaBindTexture(offset, &tex, devPtr, &desc, size);
}


































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
        size_t                            size = 0xffffffff
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}














































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch);
}













































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &tex.channelDesc, width, height, pitch);
}






























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t                       array,
  const struct cudaChannelFormatDesc     &desc
)
{
  return ::cudaBindTextureToArray(&tex, array, &desc);
}





























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t                       array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}






























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t              mipmappedArray,
  const struct cudaChannelFormatDesc     &desc
)
{
  return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc);
}





























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t              mipmappedArray
)
{
  struct cudaChannelFormatDesc desc;
  cudaArray_t                  levelArray;
  cudaError_t                  err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0);
  
  if (err != cudaSuccess) {
      return err;
  }
  err = ::cudaGetChannelDesc(&desc, levelArray);

  return err == cudaSuccess ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err;
}






















template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaUnbindTexture(&tex);
}



























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaGetTextureAlignmentOffset(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaGetTextureAlignmentOffset(offset, &tex);
}













































template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncSetCacheConfig(
  T                  *func,
  enum cudaFuncCache  cacheConfig
)
{
  return ::cudaFuncSetCacheConfig((const void*)func, cacheConfig);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncSetSharedMemConfig(
  T                        *func,
  enum cudaSharedMemConfig  config
)
{
  return ::cudaFuncSetSharedMemConfig((const void*)func, config);
}

























template<class T>
__inline __declspec(__host__) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
    int   *numBlocks,
    T      func,
    int    blockSize,
    size_t dynamicSMemSize)
{
  return ::cudaOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks, (const void*)func, blockSize, dynamicSMemSize);
}




class __cudaOccupancyB2DHelper {
  size_t n;
public:
  inline __declspec(__host__)  __cudaOccupancyB2DHelper(size_t n) : n(n) {}
  inline __declspec(__host__)  size_t operator()(int)
  {
      return n;
  }
};
































template<class T>
__inline __declspec(__host__)  cudaError_t cudaOccupancyMaxPotentialBlockSize(
    int    *minGridSize,
    int    *blockSize,
    T       func,
    size_t  dynamicSMemSize = 0,
    int     blockSizeLimit = 0)
{
  return cudaOccupancyMaxPotentialBlockSizeVariableSMem(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit);
}





























template<typename UnaryFunction, class T>
__inline __declspec(__host__)  cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMem(
    int           *minGridSize,
    int           *blockSize,
    T              func,
    UnaryFunction  blockSizeToDynamicSMemSize,
    int            blockSizeLimit = 0)
{
    cudaError_t status;

    
    int                       device;
    struct cudaFuncAttributes attr;

    
    int maxThreadsPerMultiProcessor;
    int warpSize;
    int devMaxThreadsPerBlock;
    int multiProcessorCount;
    int funcMaxThreadsPerBlock;
    int occupancyLimit;
    int granularity;

    
    int maxBlockSize = 0;
    int numBlocks    = 0;
    int maxOccupancy = 0;

    
    int blockSizeToTryAligned;
    int blockSizeToTry;
    int blockSizeLimitAligned;
    int occupancyInBlocks;
    int occupancyInThreads;
    int dynamicSMemSize;

    
    
    

    if (!minGridSize || !blockSize || !func) {
        return cudaErrorInvalidValue;
    }

    
    
    

    status = ::cudaGetDevice(&device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &maxThreadsPerMultiProcessor,
        cudaDevAttrMaxThreadsPerMultiProcessor,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &warpSize,
        cudaDevAttrWarpSize,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &devMaxThreadsPerBlock,
        cudaDevAttrMaxThreadsPerBlock,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &multiProcessorCount,
        cudaDevAttrMultiProcessorCount,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaFuncGetAttributes(&attr, func);
    if (status != cudaSuccess) {
        return status;
    }
    
    funcMaxThreadsPerBlock = attr.maxThreadsPerBlock;

    
    
    

    occupancyLimit = maxThreadsPerMultiProcessor;
    granularity    = warpSize;

    if (blockSizeLimit == 0) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (devMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (funcMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = funcMaxThreadsPerBlock;
    }

    blockSizeLimitAligned = ((blockSizeLimit + (granularity - 1)) / granularity) * granularity;

    for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) {
        
        
        
        if (blockSizeLimit < blockSizeToTryAligned) {
            blockSizeToTry = blockSizeLimit;
        } else {
            blockSizeToTry = blockSizeToTryAligned;
        }
        
        dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry);

        status = cudaOccupancyMaxActiveBlocksPerMultiprocessor(
            &occupancyInBlocks,
            func,
            blockSizeToTry,
            dynamicSMemSize);

        if (status != cudaSuccess) {
            return status;
        }

        occupancyInThreads = blockSizeToTry * occupancyInBlocks;

        if (occupancyInThreads > maxOccupancy) {
            maxBlockSize = blockSizeToTry;
            numBlocks    = occupancyInBlocks;
            maxOccupancy = occupancyInThreads;
        }

        
        
        if (occupancyLimit == maxOccupancy) {
            break;
        }
    }

    
    
    

    
    
    *minGridSize = numBlocks * multiProcessorCount;
    *blockSize = maxBlockSize;

    return status;
}



































template<class T>
__inline __declspec(__host__) cudaError_t cudaLaunch(
  T *func
)
{
  return ::cudaLaunch((const void*)func);
}































template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T                         *entry
)
{
  return ::cudaFuncGetAttributes(attr, (const void*)entry);
}





















template<class T, int dim>
__inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim>       &surf,
  cudaArray_const_t                   array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindSurfaceToArray(&surf, array, &desc);
}




















template<class T, int dim>
__inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t             array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}

#line 1614 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"

 

} 

#line 1620 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"

#line 1622 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"

#line 1 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"
#line 1 "c:\\users\\sleazy tek\\documents\\visual studio 2010\\projects\\sift-gpu-thesis\\sift-gpu-thesis\\sift.h"






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
































































































































































































































































































































































































































































































































































































































































#line 642 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

#line 8 "c:\\users\\sleazy tek\\documents\\visual studio 2010\\projects\\sift-gpu-thesis\\sift-gpu-thesis\\sift.h"
























typedef struct SiftKeypoint_t {
    int o; 
    float x; 
    float y; 
    float s; 
    float ori; 
    float mag; 
    float descriptors [(128)];
} SiftKeypoint;


typedef struct pointList_t{
    SiftKeypoint self;
    struct pointList_t* next;
} pointList;


extern int current_octave;
extern float* grad_buffer;





void sift(unsigned char* img, int w, int h, char* out_filename);

void buildOB(unsigned char* img, 
             unsigned char* octaves[(20)], 
             int O, int S, 
             int* octavesW, int* octavesH);

void buildSS(unsigned char* octaves[(20)], 
             float* scaleSpace[(20)][(10)], 
             int O, int S, 
             int* octavesW, int* octavesH, 
             float sigmas[(20)][(10)]);

void DoG(float *dog[(20)][(10)-1], 
         float *scaleSpace[(20)][(10)], 
         int O, int S,
         int* octavesW, int* octavesH);

void extreme(pointList** keyHead, int* keyN,
             float* dog[(20)][(10)-1], 
             int O, int S,
             int* octavesW, int* octavesH);

void orientation(pointList* keyHead, 
                 float *scaleSpace[(20)][(10)],
                 float sigmas[(20)][(10)], 
                 int* octavesW, int* octavesH);

void write_keypoints(FILE* fp, 
                     SiftKeypoint* keys, 
                     int n);

void  render(unsigned char* img, char* out_filename,
             int O, int S, 
             int* octavesW, int* octavesH,
             pointList* keyHead, int keyN, 
             float sigmas[(20)][(10)]);

#line 95 "c:\\users\\sleazy tek\\documents\\visual studio 2010\\projects\\sift-gpu-thesis\\sift-gpu-thesis\\sift.h"

#line 2 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"































































#line 65 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
    
#line 67 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 111 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

    
    
    
    
    
#line 118 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

    
#line 121 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

    
    
    
#line 126 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

    
    
#line 130 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"




#line 135 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
#line 136 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

























extern "C" {
#line 163 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



 




#line 172 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
typedef unsigned int CUdeviceptr;
#line 174 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

#line 176 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

typedef int CUdevice;                                     
typedef struct CUctx_st *CUcontext;                       
typedef struct CUmod_st *CUmodule;                        
typedef struct CUfunc_st *CUfunction;                     
typedef struct CUarray_st *CUarray;                       
typedef struct CUmipmappedArray_st *CUmipmappedArray;     
typedef struct CUtexref_st *CUtexref;                     
typedef struct CUsurfref_st *CUsurfref;                   
typedef struct CUevent_st *CUevent;                       
typedef struct CUstream_st *CUstream;                     
typedef struct CUgraphicsResource_st *CUgraphicsResource; 
typedef unsigned long long CUtexObject;                   
typedef unsigned long long CUsurfObject;                  

typedef struct CUuuid_st {                                
    char bytes[16];
} CUuuid;












typedef struct CUipcEventHandle_st {
    char reserved[64];
} CUipcEventHandle;




typedef struct CUipcMemHandle_st {
    char reserved[64];
} CUipcMemHandle;




typedef enum CUipcMem_flags_enum {
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 0x1 
} CUipcMem_flags;

#line 225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"




typedef enum CUmemAttach_flags_enum {
    CU_MEM_ATTACH_GLOBAL = 0x1, 
    CU_MEM_ATTACH_HOST   = 0x2, 
    CU_MEM_ATTACH_SINGLE = 0x4  
} CUmemAttach_flags;




typedef enum CUctx_flags_enum {
    CU_CTX_SCHED_AUTO          = 0x00, 
    CU_CTX_SCHED_SPIN          = 0x01, 
    CU_CTX_SCHED_YIELD         = 0x02, 
    CU_CTX_SCHED_BLOCKING_SYNC = 0x04, 
    CU_CTX_BLOCKING_SYNC       = 0x04, 


    CU_CTX_SCHED_MASK          = 0x07, 
    CU_CTX_MAP_HOST            = 0x08, 
    CU_CTX_LMEM_RESIZE_TO_MAX  = 0x10, 
    CU_CTX_FLAGS_MASK          = 0x1f
} CUctx_flags;




typedef enum CUstream_flags_enum {
    CU_STREAM_DEFAULT      = 0x0, 
    CU_STREAM_NON_BLOCKING = 0x1  
} CUstream_flags;




typedef enum CUevent_flags_enum {
    CU_EVENT_DEFAULT        = 0x0, 
    CU_EVENT_BLOCKING_SYNC  = 0x1, 
    CU_EVENT_DISABLE_TIMING = 0x2, 
    CU_EVENT_INTERPROCESS   = 0x4  
} CUevent_flags;




typedef enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8  = 0x01, 
    CU_AD_FORMAT_UNSIGNED_INT16 = 0x02, 
    CU_AD_FORMAT_UNSIGNED_INT32 = 0x03, 
    CU_AD_FORMAT_SIGNED_INT8    = 0x08, 
    CU_AD_FORMAT_SIGNED_INT16   = 0x09, 
    CU_AD_FORMAT_SIGNED_INT32   = 0x0a, 
    CU_AD_FORMAT_HALF           = 0x10, 
    CU_AD_FORMAT_FLOAT          = 0x20  
} CUarray_format;




typedef enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP   = 0, 
    CU_TR_ADDRESS_MODE_CLAMP  = 1, 
    CU_TR_ADDRESS_MODE_MIRROR = 2, 
    CU_TR_ADDRESS_MODE_BORDER = 3  
} CUaddress_mode;




typedef enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT  = 0, 
    CU_TR_FILTER_MODE_LINEAR = 1  
} CUfilter_mode;




typedef enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,              
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,                    
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,                    
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,                    
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,                     
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,                     
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,                     
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,        
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8,            
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,              
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,                         
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,                         
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,           
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12,               
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,                        
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,                 
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,                       
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,              
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,               
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,                        
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,               
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,                      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,   
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,     
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,    
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29, 
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,                 
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,                
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,                       
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,                        
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,                     
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,                        
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,                 
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,           
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,                     
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,    
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,                
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,                    
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,   
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,  
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,                  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,    
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,   
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47, 
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49, 
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,                     
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54, 
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,           
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,   
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,   
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,      
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,  
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68, 
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,    
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,    
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,   
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,    
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73, 
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,               
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,          
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77, 
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,       
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,         
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,          
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,  
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,  
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,                    
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,                     
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,           
    CU_DEVICE_ATTRIBUTE_MAX
} CUdevice_attribute;




typedef struct CUdevprop_st {
    int maxThreadsPerBlock;     
    int maxThreadsDim[3];       
    int maxGridSize[3];         
    int sharedMemPerBlock;      
    int totalConstantMemory;    
    int SIMDWidth;              
    int memPitch;               
    int regsPerBlock;           
    int clockRate;              
    int textureAlign;           
} CUdevprop;




typedef enum CUpointer_attribute_enum {
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,        
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,    
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3, 
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,   
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,     
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,    
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,      
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8      
} CUpointer_attribute;




typedef enum CUfunction_attribute_enum {
    




    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,

    




    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,

    



    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,

    


    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,

    


    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,

    






    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,

    






    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,

    



    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,

    CU_FUNC_ATTRIBUTE_MAX
} CUfunction_attribute;




typedef enum CUfunc_cache_enum {
    CU_FUNC_CACHE_PREFER_NONE    = 0x00, 
    CU_FUNC_CACHE_PREFER_SHARED  = 0x01, 
    CU_FUNC_CACHE_PREFER_L1      = 0x02, 
    CU_FUNC_CACHE_PREFER_EQUAL   = 0x03  
} CUfunc_cache;




typedef enum CUsharedconfig_enum {
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE    = 0x00, 
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE  = 0x01, 
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 0x02  
} CUsharedconfig;




typedef enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST    = 0x01,    
    CU_MEMORYTYPE_DEVICE  = 0x02,    
    CU_MEMORYTYPE_ARRAY   = 0x03,    
    CU_MEMORYTYPE_UNIFIED = 0x04     
} CUmemorytype;




typedef enum CUcomputemode_enum {
    CU_COMPUTEMODE_DEFAULT           = 0, 
    CU_COMPUTEMODE_EXCLUSIVE         = 1, 
    CU_COMPUTEMODE_PROHIBITED        = 2, 
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3  
} CUcomputemode;




typedef enum CUjit_option_enum
{
    




    CU_JIT_MAX_REGISTERS = 0,

    












    CU_JIT_THREADS_PER_BLOCK,

    





    CU_JIT_WALL_TIME,

    






    CU_JIT_INFO_LOG_BUFFER,

    






    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,

    






    CU_JIT_ERROR_LOG_BUFFER,

    






    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,

    





    CU_JIT_OPTIMIZATION_LEVEL,

    





    CU_JIT_TARGET_FROM_CUCONTEXT,

    





    CU_JIT_TARGET,

    






    CU_JIT_FALLBACK_STRATEGY,

    





    CU_JIT_GENERATE_DEBUG_INFO,

    




    CU_JIT_LOG_VERBOSE,

    




    CU_JIT_GENERATE_LINE_INFO,

    





    CU_JIT_CACHE_MODE,

    CU_JIT_NUM_OPTIONS

} CUjit_option;




typedef enum CUjit_target_enum
{
    CU_TARGET_COMPUTE_10 = 10,       
    CU_TARGET_COMPUTE_11 = 11,       
    CU_TARGET_COMPUTE_12 = 12,       
    CU_TARGET_COMPUTE_13 = 13,       
    CU_TARGET_COMPUTE_20 = 20,       
    CU_TARGET_COMPUTE_21 = 21,       
    CU_TARGET_COMPUTE_30 = 30,       
    CU_TARGET_COMPUTE_32 = 32,       
    CU_TARGET_COMPUTE_35 = 35,       
    CU_TARGET_COMPUTE_37 = 37,       
    CU_TARGET_COMPUTE_50 = 50       
} CUjit_target;




typedef enum CUjit_fallback_enum
{
    CU_PREFER_PTX = 0,  

    CU_PREFER_BINARY    

} CUjit_fallback;




typedef enum CUjit_cacheMode_enum
{
    CU_JIT_CACHE_OPTION_NONE = 0, 
    CU_JIT_CACHE_OPTION_CG,       
    CU_JIT_CACHE_OPTION_CA        
} CUjit_cacheMode;




typedef enum CUjitInputType_enum
{
    



    CU_JIT_INPUT_CUBIN = 0,

    



    CU_JIT_INPUT_PTX,

    



    CU_JIT_INPUT_FATBINARY,

    



    CU_JIT_INPUT_OBJECT,

    



    CU_JIT_INPUT_LIBRARY,

    CU_JIT_NUM_INPUT_TYPES
} CUjitInputType;


typedef struct CUlinkState_st *CUlinkState;
#line 747 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"




typedef enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE           = 0x00,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY      = 0x01,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD  = 0x02,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST   = 0x04,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 0x08
} CUgraphicsRegisterFlags;




typedef enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE          = 0x00,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY     = 0x01,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02
} CUgraphicsMapResourceFlags;




typedef enum CUarray_cubemap_face_enum {
    CU_CUBEMAP_FACE_POSITIVE_X  = 0x00, 
    CU_CUBEMAP_FACE_NEGATIVE_X  = 0x01, 
    CU_CUBEMAP_FACE_POSITIVE_Y  = 0x02, 
    CU_CUBEMAP_FACE_NEGATIVE_Y  = 0x03, 
    CU_CUBEMAP_FACE_POSITIVE_Z  = 0x04, 
    CU_CUBEMAP_FACE_NEGATIVE_Z  = 0x05  
} CUarray_cubemap_face;




typedef enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE                       = 0x00, 
    CU_LIMIT_PRINTF_FIFO_SIZE                 = 0x01, 
    CU_LIMIT_MALLOC_HEAP_SIZE                 = 0x02, 
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH           = 0x03, 
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 0x04, 
    CU_LIMIT_MAX
} CUlimit;




typedef enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY           = 0x00, 
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01, 
    CU_RESOURCE_TYPE_LINEAR          = 0x02, 
    CU_RESOURCE_TYPE_PITCH2D         = 0x03  
} CUresourcetype;




typedef enum cudaError_enum {
    




    CUDA_SUCCESS                              = 0,

    



    CUDA_ERROR_INVALID_VALUE                  = 1,

    



    CUDA_ERROR_OUT_OF_MEMORY                  = 2,

    



    CUDA_ERROR_NOT_INITIALIZED                = 3,

    


    CUDA_ERROR_DEINITIALIZED                  = 4,

    




    CUDA_ERROR_PROFILER_DISABLED              = 5,

    





    CUDA_ERROR_PROFILER_NOT_INITIALIZED       = 6,

    




    CUDA_ERROR_PROFILER_ALREADY_STARTED       = 7,

    




    CUDA_ERROR_PROFILER_ALREADY_STOPPED       = 8,

    



    CUDA_ERROR_NO_DEVICE                      = 100,

    



    CUDA_ERROR_INVALID_DEVICE                 = 101,


    



    CUDA_ERROR_INVALID_IMAGE                  = 200,

    







    CUDA_ERROR_INVALID_CONTEXT                = 201,

    






    CUDA_ERROR_CONTEXT_ALREADY_CURRENT        = 202,

    


    CUDA_ERROR_MAP_FAILED                     = 205,

    


    CUDA_ERROR_UNMAP_FAILED                   = 206,

    



    CUDA_ERROR_ARRAY_IS_MAPPED                = 207,

    


    CUDA_ERROR_ALREADY_MAPPED                 = 208,

    





    CUDA_ERROR_NO_BINARY_FOR_GPU              = 209,

    


    CUDA_ERROR_ALREADY_ACQUIRED               = 210,

    


    CUDA_ERROR_NOT_MAPPED                     = 211,

    



    CUDA_ERROR_NOT_MAPPED_AS_ARRAY            = 212,

    



    CUDA_ERROR_NOT_MAPPED_AS_POINTER          = 213,

    



    CUDA_ERROR_ECC_UNCORRECTABLE              = 214,

    



    CUDA_ERROR_UNSUPPORTED_LIMIT              = 215,

    




    CUDA_ERROR_CONTEXT_ALREADY_IN_USE         = 216,

    



    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED        = 217,

    


    CUDA_ERROR_INVALID_PTX                    = 218,

    


    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT       = 219,

    


    CUDA_ERROR_INVALID_SOURCE                 = 300,

    


    CUDA_ERROR_FILE_NOT_FOUND                 = 301,

    


    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,

    


    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED      = 303,

    


    CUDA_ERROR_OPERATING_SYSTEM               = 304,

    



    CUDA_ERROR_INVALID_HANDLE                 = 400,

    



    CUDA_ERROR_NOT_FOUND                      = 500,

    





    CUDA_ERROR_NOT_READY                      = 600,

    






    CUDA_ERROR_ILLEGAL_ADDRESS                = 700,

    








    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES        = 701,

    








    CUDA_ERROR_LAUNCH_TIMEOUT                 = 702,

    



    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING  = 703,
    
    




    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED    = 704,

    




    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED        = 705,

    



    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE         = 708,

    




    CUDA_ERROR_CONTEXT_IS_DESTROYED           = 709,

    





    CUDA_ERROR_ASSERT                         = 710,

    




    CUDA_ERROR_TOO_MANY_PEERS                 = 711,

    



    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,

    



    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED     = 713,

    






    CUDA_ERROR_HARDWARE_STACK_ERROR           = 714,

    





    CUDA_ERROR_ILLEGAL_INSTRUCTION            = 715,

    






    CUDA_ERROR_MISALIGNED_ADDRESS             = 716,

    








    CUDA_ERROR_INVALID_ADDRESS_SPACE          = 717,

    





    CUDA_ERROR_INVALID_PC                     = 718,

    







    CUDA_ERROR_LAUNCH_FAILED                  = 719,


    


    CUDA_ERROR_NOT_PERMITTED                  = 800,

    



    CUDA_ERROR_NOT_SUPPORTED                  = 801,

    


    CUDA_ERROR_UNKNOWN                        = 999
} CUresult;





#line 1203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"







typedef void (__stdcall *CUstreamCallback)(CUstream hStream, CUresult status, void *userData);







typedef size_t (__stdcall *CUoccupancyB2DSize)(int blockSize);








































typedef struct CUDA_MEMCPY2D_st {
    size_t srcXInBytes;         
    size_t srcY;                

    CUmemorytype srcMemoryType; 
    const void *srcHost;        
    CUdeviceptr srcDevice;      
    CUarray srcArray;           
    size_t srcPitch;            

    size_t dstXInBytes;         
    size_t dstY;                

    CUmemorytype dstMemoryType; 
    void *dstHost;              
    CUdeviceptr dstDevice;      
    CUarray dstArray;           
    size_t dstPitch;            

    size_t WidthInBytes;        
    size_t Height;              
} CUDA_MEMCPY2D;




typedef struct CUDA_MEMCPY3D_st {
    size_t srcXInBytes;         
    size_t srcY;                
    size_t srcZ;                
    size_t srcLOD;              
    CUmemorytype srcMemoryType; 
    const void *srcHost;        
    CUdeviceptr srcDevice;      
    CUarray srcArray;           
    void *reserved0;            
    size_t srcPitch;            
    size_t srcHeight;           

    size_t dstXInBytes;         
    size_t dstY;                
    size_t dstZ;                
    size_t dstLOD;              
    CUmemorytype dstMemoryType; 
    void *dstHost;              
    CUdeviceptr dstDevice;      
    CUarray dstArray;           
    void *reserved1;            
    size_t dstPitch;            
    size_t dstHeight;           

    size_t WidthInBytes;        
    size_t Height;              
    size_t Depth;               
} CUDA_MEMCPY3D;




typedef struct CUDA_MEMCPY3D_PEER_st {
    size_t srcXInBytes;         
    size_t srcY;                
    size_t srcZ;                
    size_t srcLOD;              
    CUmemorytype srcMemoryType; 
    const void *srcHost;        
    CUdeviceptr srcDevice;      
    CUarray srcArray;           
    CUcontext srcContext;       
    size_t srcPitch;            
    size_t srcHeight;           

    size_t dstXInBytes;         
    size_t dstY;                
    size_t dstZ;                
    size_t dstLOD;              
    CUmemorytype dstMemoryType; 
    void *dstHost;              
    CUdeviceptr dstDevice;      
    CUarray dstArray;           
    CUcontext dstContext;       
    size_t dstPitch;            
    size_t dstHeight;           

    size_t WidthInBytes;        
    size_t Height;              
    size_t Depth;               
} CUDA_MEMCPY3D_PEER;




typedef struct CUDA_ARRAY_DESCRIPTOR_st
{
    size_t Width;             
    size_t Height;            

    CUarray_format Format;    
    unsigned int NumChannels; 
} CUDA_ARRAY_DESCRIPTOR;




typedef struct CUDA_ARRAY3D_DESCRIPTOR_st
{
    size_t Width;             
    size_t Height;            
    size_t Depth;             

    CUarray_format Format;    
    unsigned int NumChannels; 
    unsigned int Flags;       
} CUDA_ARRAY3D_DESCRIPTOR;

#line 1375 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"






typedef struct CUDA_RESOURCE_DESC_st
{
    CUresourcetype resType;                   

    union {
        struct {
            CUarray hArray;                   
        } array;
        struct {
            CUmipmappedArray hMipmappedArray; 
        } mipmap;
        struct {
            CUdeviceptr devPtr;               
            CUarray_format format;            
            unsigned int numChannels;         
            size_t sizeInBytes;               
        } linear;
        struct {
            CUdeviceptr devPtr;               
            CUarray_format format;            
            unsigned int numChannels;         
            size_t width;                     
            size_t height;                    
            size_t pitchInBytes;              
        } pitch2D;
        struct {
            int reserved[32];
        } reserved;
    } res;

    unsigned int flags;                       
} CUDA_RESOURCE_DESC;




typedef struct CUDA_TEXTURE_DESC_st {
    CUaddress_mode addressMode[3];  
    CUfilter_mode filterMode;       
    unsigned int flags;             
    unsigned int maxAnisotropy;     
    CUfilter_mode mipmapFilterMode; 
    float mipmapLevelBias;          
    float minMipmapLevelClamp;      
    float maxMipmapLevelClamp;      
    int reserved[16];
} CUDA_TEXTURE_DESC;




typedef enum CUresourceViewFormat_enum
{
    CU_RES_VIEW_FORMAT_NONE          = 0x00, 
    CU_RES_VIEW_FORMAT_UINT_1X8      = 0x01, 
    CU_RES_VIEW_FORMAT_UINT_2X8      = 0x02, 
    CU_RES_VIEW_FORMAT_UINT_4X8      = 0x03, 
    CU_RES_VIEW_FORMAT_SINT_1X8      = 0x04, 
    CU_RES_VIEW_FORMAT_SINT_2X8      = 0x05, 
    CU_RES_VIEW_FORMAT_SINT_4X8      = 0x06, 
    CU_RES_VIEW_FORMAT_UINT_1X16     = 0x07, 
    CU_RES_VIEW_FORMAT_UINT_2X16     = 0x08, 
    CU_RES_VIEW_FORMAT_UINT_4X16     = 0x09, 
    CU_RES_VIEW_FORMAT_SINT_1X16     = 0x0a, 
    CU_RES_VIEW_FORMAT_SINT_2X16     = 0x0b, 
    CU_RES_VIEW_FORMAT_SINT_4X16     = 0x0c, 
    CU_RES_VIEW_FORMAT_UINT_1X32     = 0x0d, 
    CU_RES_VIEW_FORMAT_UINT_2X32     = 0x0e, 
    CU_RES_VIEW_FORMAT_UINT_4X32     = 0x0f, 
    CU_RES_VIEW_FORMAT_SINT_1X32     = 0x10, 
    CU_RES_VIEW_FORMAT_SINT_2X32     = 0x11, 
    CU_RES_VIEW_FORMAT_SINT_4X32     = 0x12, 
    CU_RES_VIEW_FORMAT_FLOAT_1X16    = 0x13, 
    CU_RES_VIEW_FORMAT_FLOAT_2X16    = 0x14, 
    CU_RES_VIEW_FORMAT_FLOAT_4X16    = 0x15, 
    CU_RES_VIEW_FORMAT_FLOAT_1X32    = 0x16, 
    CU_RES_VIEW_FORMAT_FLOAT_2X32    = 0x17, 
    CU_RES_VIEW_FORMAT_FLOAT_4X32    = 0x18, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1  = 0x19, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2  = 0x1a, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3  = 0x1b, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4  = 0x1c, 
    CU_RES_VIEW_FORMAT_SIGNED_BC4    = 0x1d, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5  = 0x1e, 
    CU_RES_VIEW_FORMAT_SIGNED_BC5    = 0x1f, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 0x20, 
    CU_RES_VIEW_FORMAT_SIGNED_BC6H   = 0x21, 
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7  = 0x22  
} CUresourceViewFormat;




typedef struct CUDA_RESOURCE_VIEW_DESC_st
{
    CUresourceViewFormat format;   
    size_t width;                  
    size_t height;                 
    size_t depth;                  
    unsigned int firstMipmapLevel; 
    unsigned int lastMipmapLevel;  
    unsigned int firstLayer;       
    unsigned int lastLayer;        
    unsigned int reserved[16];
} CUDA_RESOURCE_VIEW_DESC;




typedef struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    unsigned long long p2pToken;
    unsigned int vaSpaceToken;
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS;

#line 1496 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

































































































 





#line 1600 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"






























CUresult __stdcall cuGetErrorString(CUresult error, const char **pStr);


















CUresult __stdcall cuGetErrorName(CUresult error, const char **pStr);

 





























CUresult __stdcall cuInit(unsigned int Flags);

 



























CUresult __stdcall cuDriverGetVersion(int *driverVersion);

 





































CUresult __stdcall cuDeviceGet(CUdevice *device, int ordinal);
























CUresult __stdcall cuDeviceGetCount(int *count);



























CUresult __stdcall cuDeviceGetName(char *name, int len, CUdevice dev);


























CUresult __stdcall cuDeviceTotalMem_v2(size_t *bytes, CUdevice dev);
#line 1833 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
























































































































































































CUresult __stdcall cuDeviceGetAttribute(int *pi, CUdevice_attribute attrib, CUdevice dev);

 










































































CUresult __stdcall cuDeviceGetProperties(CUdevprop *prop, CUdevice dev);
































CUresult __stdcall cuDeviceComputeCapability(int *major, int *minor, CUdevice dev);

 



































































































CUresult __stdcall cuCtxCreate_v2(CUcontext *pctx, unsigned int flags, CUdevice dev);
#line 2231 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"





































CUresult __stdcall cuCtxDestroy_v2(CUcontext ctx);
#line 2270 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

































CUresult __stdcall cuCtxPushCurrent_v2(CUcontext ctx);
































CUresult __stdcall cuCtxPopCurrent_v2(CUcontext *pctx);

























CUresult __stdcall cuCtxSetCurrent(CUcontext ctx);


















CUresult __stdcall cuCtxGetCurrent(CUcontext *pctx);
#line 2383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



























CUresult __stdcall cuCtxGetDevice(CUdevice *device);



























CUresult __stdcall cuCtxSynchronize(void);





























































































CUresult __stdcall cuCtxSetLimit(CUlimit limit, size_t value);





































CUresult __stdcall cuCtxGetLimit(size_t *pvalue, CUlimit limit);









































CUresult __stdcall cuCtxGetCacheConfig(CUfunc_cache *pconfig);
















































CUresult __stdcall cuCtxSetCacheConfig(CUfunc_cache config);








































CUresult __stdcall cuCtxGetSharedMemConfig(CUsharedconfig *pConfig);


















































CUresult __stdcall cuCtxSetSharedMemConfig(CUsharedconfig config);
#line 2755 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



































CUresult __stdcall cuCtxGetApiVersion(CUcontext ctx, unsigned int *version);





































CUresult __stdcall cuCtxGetStreamPriorityRange(int *leastPriority, int *greatestPriority);

 



















































CUresult __stdcall cuCtxAttach(CUcontext *pctx, unsigned int flags);


































CUresult __stdcall cuCtxDetach(CUcontext ctx);

 



















































CUresult __stdcall cuModuleLoad(CUmodule *module, const char *fname);



































CUresult __stdcall cuModuleLoadData(CUmodule *module, const void *image);









































CUresult __stdcall cuModuleLoadDataEx(CUmodule *module, const void *image, unsigned int numOptions, CUjit_option *options, void **optionValues);








































CUresult __stdcall cuModuleLoadFatBinary(CUmodule *module, const void *fatCubin);
























CUresult __stdcall cuModuleUnload(CUmodule hmod);





























CUresult __stdcall cuModuleGetFunction(CUfunction *hfunc, CUmodule hmod, const char *name);

































CUresult __stdcall cuModuleGetGlobal_v2(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);
#line 3181 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
































CUresult __stdcall cuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const char *name);






























CUresult __stdcall cuModuleGetSurfRef(CUsurfref *pSurfRef, CUmodule hmod, const char *name);








































CUresult __stdcall
cuLinkCreate_v2(unsigned int numOptions, CUjit_option *options, void **optionValues, CUlinkState *stateOut);



































CUresult __stdcall
cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void *data, size_t size, const char *name,
    unsigned int numOptions, CUjit_option *options, void **optionValues);




































CUresult __stdcall
cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char *path,
    unsigned int numOptions, CUjit_option *options, void **optionValues);
























CUresult __stdcall
cuLinkComplete(CUlinkState state, void **cubinOut, size_t *sizeOut);












CUresult __stdcall
cuLinkDestroy(CUlinkState state);

#line 3406 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

 











































CUresult __stdcall cuMemGetInfo_v2(size_t *free, size_t *total);
































CUresult __stdcall cuMemAlloc_v2(CUdeviceptr *dptr, size_t bytesize);




























































CUresult __stdcall cuMemAllocPitch_v2(CUdeviceptr *dptr, size_t *pPitch, size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes);




























CUresult __stdcall cuMemFree_v2(CUdeviceptr dptr);
































CUresult __stdcall cuMemGetAddressRange_v2(CUdeviceptr *pbase, size_t *psize, CUdeviceptr dptr);













































CUresult __stdcall cuMemAllocHost_v2(void **pp, size_t bytesize);
#line 3655 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"




























CUresult __stdcall cuMemFreeHost(void *p);

















































































CUresult __stdcall cuMemHostAlloc(void **pp, size_t bytesize, unsigned int Flags);





































CUresult __stdcall cuMemHostGetDevicePointer_v2(CUdeviceptr *pdptr, void *p, unsigned int Flags);
#line 3805 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"























CUresult __stdcall cuMemHostGetFlags(unsigned int *pFlags, void *p);

















































































CUresult __stdcall cuMemAllocManaged(CUdeviceptr *dptr, size_t bytesize, unsigned int flags);

#line 3913 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"


























CUresult __stdcall cuDeviceGetByPCIBusId(CUdevice *dev, const char *pciBusId);



























CUresult __stdcall cuDeviceGetPCIBusId(char *pciBusId, int len, CUdevice dev);









































CUresult __stdcall cuIpcGetEventHandle(CUipcEventHandle *pHandle, CUevent event);




































CUresult __stdcall cuIpcOpenEventHandle(CUevent *phEvent, CUipcEventHandle handle);




































CUresult __stdcall cuIpcGetMemHandle(CUipcMemHandle *pHandle, CUdeviceptr dptr);


















































CUresult __stdcall cuIpcOpenMemHandle(CUdeviceptr *pdptr, CUipcMemHandle handle, unsigned int Flags);






























CUresult __stdcall cuIpcCloseMemHandle(CUdeviceptr dptr);

#line 4168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"




























































CUresult __stdcall cuMemHostRegister_v2(void *p, size_t bytesize, unsigned int Flags);























CUresult __stdcall cuMemHostUnregister(void *p);



































CUresult __stdcall cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount);




























CUresult __stdcall cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount);

#line 4320 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

































CUresult __stdcall cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount);
































CUresult __stdcall cuMemcpyDtoH_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount);
































CUresult __stdcall cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount);


































CUresult __stdcall cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount);




































CUresult __stdcall cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount);


































CUresult __stdcall cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount);


































CUresult __stdcall cuMemcpyAtoH_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount);






































CUresult __stdcall cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount);
































































































































































CUresult __stdcall cuMemcpy2D_v2(const CUDA_MEMCPY2D *pCopy);






























































































































































CUresult __stdcall cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D *pCopy);







































































































































































CUresult __stdcall cuMemcpy3D_v2(const CUDA_MEMCPY3D *pCopy);
#line 5090 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"























CUresult __stdcall cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER *pCopy);







































CUresult __stdcall cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream);






























CUresult __stdcall cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream);
#line 5186 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"





































CUresult __stdcall cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount, CUstream hStream);




































CUresult __stdcall cuMemcpyDtoHAsync_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);




































CUresult __stdcall cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);






































CUresult __stdcall cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount, CUstream hStream);






































CUresult __stdcall cuMemcpyAtoHAsync_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream);




































































































































































CUresult __stdcall cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D *pCopy, CUstream hStream);











































































































































































CUresult __stdcall cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D *pCopy, CUstream hStream);
#line 5714 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

























CUresult __stdcall cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER *pCopy, CUstream hStream);
#line 5741 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"


































CUresult __stdcall cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N);

































CUresult __stdcall cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N);

































CUresult __stdcall cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned int ui, size_t N);






































CUresult __stdcall cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height);







































CUresult __stdcall cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height);







































CUresult __stdcall cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height);



































CUresult __stdcall cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream);



































CUresult __stdcall cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream);


































CUresult __stdcall cuMemsetD32Async(CUdeviceptr dstDevice, unsigned int ui, size_t N, CUstream hStream);








































CUresult __stdcall cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream);









































CUresult __stdcall cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream);









































CUresult __stdcall cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, CUstream hStream);






































































































CUresult __stdcall cuArrayCreate_v2(CUarray *pHandle, const CUDA_ARRAY_DESCRIPTOR *pAllocateArray);
































CUresult __stdcall cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
#line 6332 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"





























CUresult __stdcall cuArrayDestroy(CUarray hArray);



















































































































































































CUresult __stdcall cuArray3DCreate_v2(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);



































CUresult __stdcall cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
#line 6579 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"





























































































































CUresult __stdcall cuMipmappedArrayCreate(CUmipmappedArray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pMipmappedArrayDesc, unsigned int numMipmapLevels);

























CUresult __stdcall cuMipmappedArrayGetLevel(CUarray *pLevelArray, CUmipmappedArray hMipmappedArray, unsigned int level);



















CUresult __stdcall cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray);

#line 6753 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

 

















































































































































































































































CUresult __stdcall cuPointerGetAttribute(void *data, CUpointer_attribute attribute, CUdeviceptr ptr);
#line 6998 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"









































CUresult __stdcall cuPointerSetAttribute(const void *value, CUpointer_attribute attribute, CUdeviceptr ptr);
#line 7041 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

 












































CUresult __stdcall cuStreamCreate(CUstream *phStream, unsigned int Flags);















































CUresult __stdcall cuStreamCreateWithPriority(CUstream *phStream, unsigned int flags, int priority);





























CUresult __stdcall cuStreamGetPriority(CUstream hStream, int *priority);


























CUresult __stdcall cuStreamGetFlags(CUstream hStream, unsigned int *flags);








































CUresult __stdcall cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned int Flags);






































































CUresult __stdcall cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void *userData, unsigned int flags);











































































CUresult __stdcall cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned int flags);

#line 7383 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"




























CUresult __stdcall cuStreamQuery(CUstream hStream);


























CUresult __stdcall cuStreamSynchronize(CUstream hStream);




























CUresult __stdcall cuStreamDestroy_v2(CUstream hStream);
#line 7469 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

 



















































CUresult __stdcall cuEventCreate(CUevent *phEvent, unsigned int Flags);



































CUresult __stdcall cuEventRecord(CUevent hEvent, CUstream hStream);

































CUresult __stdcall cuEventQuery(CUevent hEvent);

































CUresult __stdcall cuEventSynchronize(CUevent hEvent);




























CUresult __stdcall cuEventDestroy_v2(CUevent hEvent);
#line 7657 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"










































CUresult __stdcall cuEventElapsedTime(float *pMilliseconds, CUevent hStart, CUevent hEnd);

 
































































CUresult __stdcall cuFuncGetAttribute(int *pi, CUfunction_attribute attrib, CUfunction hfunc);










































CUresult __stdcall cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config);



















































CUresult __stdcall cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config);
#line 7863 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
















































































































CUresult __stdcall cuLaunchKernel(CUfunction f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                CUstream hStream,
                                void **kernelParams,
                                void **extra);
#line 7987 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

 















































CUresult __stdcall cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z);

































CUresult __stdcall cuFuncSetSharedSize(CUfunction hfunc, unsigned int bytes);































CUresult __stdcall cuParamSetSize(CUfunction hfunc, unsigned int numbytes);
































CUresult __stdcall cuParamSeti(CUfunction hfunc, int offset, unsigned int value);
































CUresult __stdcall cuParamSetf(CUfunction hfunc, int offset, float value);


































CUresult __stdcall cuParamSetv(CUfunction hfunc, int offset, void *ptr, unsigned int numbytes);




































CUresult __stdcall cuLaunch(CUfunction f);






































CUresult __stdcall cuLaunchGrid(CUfunction f, int grid_width, int grid_height);














































CUresult __stdcall cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream);
























CUresult __stdcall cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef);
 




































CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize);

















































CUresult __stdcall cuOccupancyMaxPotentialBlockSize(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit);

 
#line 8443 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"







































CUresult __stdcall cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned int Flags);


























CUresult __stdcall cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned int Flags);











































CUresult __stdcall cuTexRefSetAddress_v2(size_t *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes);



















































CUresult __stdcall cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);
#line 8607 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



























CUresult __stdcall cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents);







































CUresult __stdcall cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am);
































CUresult __stdcall cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm);
































CUresult __stdcall cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm);

























CUresult __stdcall cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias);



























CUresult __stdcall cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp);

























CUresult __stdcall cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned int maxAniso);


































CUresult __stdcall cuTexRefSetFlags(CUtexref hTexRef, unsigned int Flags);

























CUresult __stdcall cuTexRefGetAddress_v2(CUdeviceptr *pdptr, CUtexref hTexRef);
#line 8883 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
























CUresult __stdcall cuTexRefGetArray(CUarray *phArray, CUtexref hTexRef);
























CUresult __stdcall cuTexRefGetMipmappedArray(CUmipmappedArray *phMipmappedArray, CUtexref hTexRef);

























CUresult __stdcall cuTexRefGetAddressMode(CUaddress_mode *pam, CUtexref hTexRef, int dim);























CUresult __stdcall cuTexRefGetFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);

























CUresult __stdcall cuTexRefGetFormat(CUarray_format *pFormat, int *pNumChannels, CUtexref hTexRef);























CUresult __stdcall cuTexRefGetMipmapFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);























CUresult __stdcall cuTexRefGetMipmapLevelBias(float *pbias, CUtexref hTexRef);
























CUresult __stdcall cuTexRefGetMipmapLevelClamp(float *pminMipmapLevelClamp, float *pmaxMipmapLevelClamp, CUtexref hTexRef);























CUresult __stdcall cuTexRefGetMaxAnisotropy(int *pmaxAniso, CUtexref hTexRef);






















CUresult __stdcall cuTexRefGetFlags(unsigned int *pFlags, CUtexref hTexRef);

 




































CUresult __stdcall cuTexRefCreate(CUtexref *pTexRef);



















CUresult __stdcall cuTexRefDestroy(CUtexref hTexRef);

 




































CUresult __stdcall cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned int Flags);




















CUresult __stdcall cuSurfRefGetArray(CUarray *phArray, CUsurfref hSurfRef);

 

























































































































































































































CUresult __stdcall cuTexObjectCreate(CUtexObject *pTexObject, const CUDA_RESOURCE_DESC *pResDesc, const CUDA_TEXTURE_DESC *pTexDesc, const CUDA_RESOURCE_VIEW_DESC *pResViewDesc);

















CUresult __stdcall cuTexObjectDestroy(CUtexObject texObject);


















CUresult __stdcall cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUtexObject texObject);


















CUresult __stdcall cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC *pTexDesc, CUtexObject texObject);



















CUresult __stdcall cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC *pResViewDesc, CUtexObject texObject);

 




































CUresult __stdcall cuSurfObjectCreate(CUsurfObject *pSurfObject, const CUDA_RESOURCE_DESC *pResDesc);

















CUresult __stdcall cuSurfObjectDestroy(CUsurfObject surfObject);


















CUresult __stdcall cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUsurfObject surfObject);

 
#line 9623 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"













    
























CUresult __stdcall cuDeviceCanAccessPeer(int *canAccessPeer, CUdevice dev, CUdevice peerDev);














































CUresult __stdcall cuCtxEnablePeerAccess(CUcontext peerContext, unsigned int Flags);
























CUresult __stdcall cuCtxDisablePeerAccess(CUcontext peerContext);

 
#line 9737 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"








































CUresult __stdcall cuGraphicsUnregisterResource(CUgraphicsResource resource);





































CUresult __stdcall cuGraphicsSubResourceGetMappedArray(CUarray *pArray, CUgraphicsResource resource, unsigned int arrayIndex, unsigned int mipLevel);






























CUresult __stdcall cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray *pMipmappedArray, CUgraphicsResource resource);

#line 9849 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"

































CUresult __stdcall cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr *pDevPtr, size_t *pSize, CUgraphicsResource resource);
#line 9884 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"







































CUresult __stdcall cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned int flags);






































CUresult __stdcall cuGraphicsMapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);



































CUresult __stdcall cuGraphicsUnmapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);

 

CUresult __stdcall cuGetExportTable(const void **ppExportTable, const CUuuid *pExportTableId);


























































#line 10062 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



#line 10066 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



#line 10070 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"







#line 10078 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



#line 10082 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"














#line 10097 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"
























































































































#line 10218 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"






#line 10225 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"










#line 10236 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"


}
#line 10240 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"



#line 10244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda.h"


#line 3 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1622 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\cuda_runtime.h"

#line 4 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\device_launch_parameters.h"
















































































































#line 114 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.5\\include\\device_launch_parameters.h"
#line 5 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"

#line 1 "c:\\users\\sleazy tek\\documents\\visual studio 2010\\projects\\sift-gpu-thesis\\sift-gpu-thesis\\gpusift.cuh"






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
































































































































































































































































































































































































































































































































































































































































#line 642 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"

#line 8 "c:\\users\\sleazy tek\\documents\\visual studio 2010\\projects\\sift-gpu-thesis\\sift-gpu-thesis\\gpusift.cuh"











void GPUbuildOB(unsigned char* , 
             unsigned char* , 
             int, int, 
             int* , int*);

__declspec(__global__) void GPUdownsample(unsigned char*,
                int, int,
                unsigned char*,
                int, int);


#line 31 "c:\\users\\sleazy tek\\documents\\visual studio 2010\\projects\\sift-gpu-thesis\\sift-gpu-thesis\\gpusift.cuh"
#line 7 "C:/Users/sleazy tek/Documents/Visual Studio 2010/Projects/SIFT-GPU-Thesis/SIFT-GPU-Thesis/GPUbuildOB.cu"

extern "C" __declspec(__global__) void GPUdownsample(unsigned char* target,
                int targetW, int targetH,
                unsigned char* src,
                int srcW, int srcH){
					
					int x=blockIdx.x;
					int y=threadIdx.x;
					



					target[x*targetW+y] = (unsigned char)
                ( (int)
                  ((int)src[x*2*srcW+y*2] +
                   (int)src[x*2*srcW+y*2+1] +
                   (int)src[(x*2+1)*srcW+y*2] +
                   (int)src[(x*2+1)*srcW+y*2+1]) 
                  / 4 );


				
					 }




extern "C" void GPUbuildOB(unsigned char* img,	
             unsigned char* octaves[(20)],		
             int O, int S,						
             int* octavesW, int* octavesH){		
  

    int i;
	unsigned char *GPUimg;	
	unsigned char* GPUoctaves[(20)];	


		
	cudaMalloc(&GPUimg,sizeof(unsigned char)*octavesW[0]*octavesH[0]);		
		
	for(i=0;i<O;i++){	
			cudaMalloc(&GPUoctaves[i],sizeof(unsigned char)*octavesW[i]*octavesH[i]);	
		}
	

	cudaMemcpy(GPUimg, img, sizeof(unsigned char)*octavesW[0]*octavesH[0], cudaMemcpyHostToDevice);	
	cudaMemcpy(GPUoctaves[0], GPUimg, sizeof(unsigned char)*octavesW[0]*octavesH[0], cudaMemcpyDeviceToDevice);	


	for(i=0;i<O;i++){									
		GPUdownsample<<<octavesH[i],					
						octavesW[i]>>>					
						(GPUoctaves[i],					
						octavesW[i], octavesH[i],		
						GPUoctaves[i-1],				
						octavesW[i-1], octavesH[i-1]);	
		}




	cudaFree(GPUimg);
	cudaFree(GPUoctaves);
	
}
