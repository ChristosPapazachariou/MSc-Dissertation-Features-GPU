/***********************************************************************************************************************
This file is part of "SIFT-GPU-Thesis" project.
 * Copyright (C) 2015 {Christos Papazachariou} <{christospapazachariou@gmail.com}>
 * University of Piraeus- MSc program: Advanced Information Systems ("Embedded System Technologies" branch).
 * Partial or otherwise use of this project and/or source code is permitted only for educational and academic purposes.
 * Partial or otherwise use of this project and/or source code for commercial or militay applications is prohibited.
***********************************************************************************************************************/

#include "sift.h"
#include "cuda.h"
#include "cuda_runtime.h"
#include "device_launch_parameters.h"

extern "C" {
	#include "gpusift.h"
	#include "MYtimer.h"
	//#include "ioocv.h"
}

#define CURVATURE_THRESHOLD 10.0f
	//#define CURVATURE_THRESHOLD 1.0f
#define FLAGYES 1

/************************************************
 * extreme:
 * Find extreme points, store them in linked list
 *
 * Parameter
 * keyHead: output, head of the linked list
 * keyN: output, nr. of key points in linked list
 * dog: input, generated by DoG (diff of gaussian)
 * O: number of octaves
 * S: scales per octave
 * octavesW: output, width of each octave
 * octavesH: output, height of each octave
 ***********************************************/
extern "C" {
	void GPUextreme(pointList** keyHead, int* keyN,
				 float* dog[MAX_O][MAX_S-1], 
				 int O, int S,
				 int* octavesW, int* octavesH){

		// common variables
		int i, j;
		//int ii,jj;
		float* self;
		float* up;
		float* down;
		int w, h;
		// peak threshold (empirical number)
		float peakThres = 3.0;
		float* GPUdog[MAX_O][MAX_S-1];
		int* GPUflagExtrema[MAX_O][MAX_S-3];	
		int* GPUflagEdge[MAX_O][MAX_S-3];
		float GPUradius[MAX_O][MAX_S];
		//float radius;

		int* flagEdge[MAX_O][MAX_S-3];	//only this to copy from gpu and send to keypoints linked list
		int* flagExtrema[MAX_O][MAX_S-3];	//only this to copy from gpu and send to keypoints linked list
	    
		float sigma0 = 1.6f;
		float sigmas[MAX_O][MAX_S];		// sigma at each scale

		printf("GPUextreme call.\n");
		logtime2("GPUextreme start");

	//CPU MALLOC
		logtime2("CPU malloc start");
		for (i=0;i<O;i++){
			for(j=0;j<S-3;j++){
				flagEdge[i][j]=(int*)malloc(sizeof(int)*octavesH[i]*octavesW[i]);	//here to store int flags from the stream compaction
			}
		}
		logtime2("CPU malloc end");
		printf("\tCPU flagEdge allocated, O=%d, S=%d\n",i,j);
		logtime2("CPU malloc start");
		for (i=0;i<O;i++){
			for(j=0;j<S-3;j++){
				flagExtrema[i][j]=(int*)malloc(sizeof(int)*octavesH[i]*octavesW[i]);	//here to store int flags from the stream compaction
			}
		}
		logtime2("CPU malloc end");
		printf("\tCPU flagExtrema allocated, O=%d, S=%d\n",i,j);

	//CUDA VAR CALCS
				/**********************************
				 * Patch:
				 * Avoid points close to the border.
				 * Loop bounds are changed accordingly.
				 * The margin are set to "radius",
				 * which is the radius of ori computation.
				 **********************************/
		logtime2("CPU var calcs start");
		for(i = 0; i < O; i++){
			for(j = 0; j < S; j++){
				sigmas[i][j] = 
					sigma0 * 
					pow(sqrt(2.0f), (float)j/(float)(S-3));
			
				GPUradius[i][j]=1.5f*sigmas[i][j];
			}
		}
		logtime2("CPU var calcs end");
		printf("\tSigmas and radia calculated, O=%d, S=%d\n",i,j);

//CUDAMALLOCS
		logtime2("GPU malloc start");
		for(i = 0; i < O; i++){
			for(j = 0; j < S-1; j++){
				if(cudaMalloc(&GPUdog[i][j],sizeof(float)*octavesH[i]*octavesW[i])!=cudaSuccess){
					cudaError_t error = cudaGetLastError();
					printf ("cudaMalloc Error! GPUdog\tCUDA error: %s\n",cudaGetErrorString(error));	
					cudaFree(GPUdog);
				}
			}
		}
		//printf("\tGPUdog memory allocated, O=%d, S=%d\n",i,j);

		for(i = 0; i < O; i++){
			for(j = 0; j < S-3; j++){	//mind to address as j-1 or off by 1 error
				if(cudaMalloc(&GPUflagExtrema[i][j],sizeof(int)*octavesH[i]*octavesW[i])!=cudaSuccess){
					cudaError_t error = cudaGetLastError();
					printf ("cudaMalloc Error! flagExtrema\tCUDA error: %s\n",cudaGetErrorString(error));	
					cudaFree(GPUflagExtrema);
				}
			}
		}
		//printf("\tGPUflagExtrema memory allocated, O=%d, S=%d\n",i,j);

		for(i = 0; i < O; i++){
			for(j = 0; j < S-3; j++){	//mind to address as j-1 or off by 1 error
				if(cudaMalloc(&GPUflagEdge[i][j],sizeof(int)*octavesH[i]*octavesW[i])!=cudaSuccess){
					cudaError_t error = cudaGetLastError();
					printf ("cudaMalloc Error! GPUflagEdge\tCUDA error: %s\n",cudaGetErrorString(error));	
					cudaFree(GPUflagEdge);
				}
			}
		}
		//printf("\tGPUflagEdge memory allocated, O=%d, S=%d\n",i,j);
		logtime2("GPU malloc end");

//CUDAMEMCPYS TO DEV
		logtime2("GPU memcpy to dev start");
		for (i=0; i<O; i++){
			for (j=0; j<S-1; j++){
				if(cudaMemcpy(GPUdog[i][j],dog[i][j],sizeof(float)*octavesW[i]*octavesH[i],cudaMemcpyHostToDevice)!=cudaSuccess){
						cudaError_t error = cudaGetLastError();
						printf ("cudaMemcpyHostToDevice Error! GPUdog[%d][%d]\tCUDA error: %s\n",i,j,cudaGetErrorString(error));
						cudaFree(GPUdog);
				}
			}
		}
		logtime2("GPU memcpy to end end");
		printf("\tGPUdog uploaded to GPU, O=%d, S=%d\n",i,j);

//KERNEL LAUNCHES  
		logtime2("GPU extrema start");
		for(i = 0; i < O; i++){
			for(j = 1; j < S-2; j++){
				w = octavesW[i];
				h = octavesH[i];
				self = GPUdog[i][j];
				up = GPUdog[i][j+1];
				down = GPUdog[i][j-1];

						const dim3 block(32,32);	//reasonable block size (1024 threads/block) 
						const dim3 grid((octavesW[i]+block.x-1)/block.x,(octavesH[i]+block.x-1)/block.y);	//make sure at least 1x1 kernel

				GPUcheckExtrema<<<grid,block>>>(self,up,down,w,h,GPUradius[i][j],peakThres,GPUflagExtrema[i][j-1]);	
				//GPUcheckEE<<<grid,block>>>(self,up,down,w,h,GPUradius[i][j],peakThres,GPUflagEdge[i][j-1]);

				//printf("\t\tkernel: GPUcheckExtrema[%d][%d]. GPUflagExtrema[%d][%d]\t",i,j,i,j-1);
				//GPUcheckEdge<<<grid,block>>>(self, w, h, GPUflagExtrema[i][j-1], GPUflagEdge[i][j-1]);
				//printf("\t\tkernel: GPUcheckEdge[%d][%d]. flagEdge[%d][%d]\n",i,j,i,j-1);
			}
		}
		logtime2("GPU extrema end");
		//logtime2("GPU edge start");
		for(i=0;i<O;i++){
			for (j=0; j<S-3; j++){
				const dim3 block(32,32);	//reasonable block size (1024 threads/block) 
				const dim3 grid((octavesW[i]+block.x-1)/block.x,(octavesH[i]+block.x-1)/block.y);	//make sure at least 1x1 kernel
//BUG: this  loop call does not work as it is, no timelogs are kept for this until it does
				GPUcheckEdge<<<grid,block>>>(GPUdog[i][j+1],octavesW[i], octavesH[i], GPUflagExtrema[i][j],GPUflagEdge[i][j]);
			}
		}
		//logtime2("GPU edge end");

		printf("\tGPU operations complete O=%d, S=%d . Downloading from GPU...\n",i,j);

	//CUDAMEMCPYS TO HOST
		logtime2("GPU memcpy to host start");

//BUG: this loop will not be needed once the bug of GPUcheckEdge is fixed
		for (i=0; i<O; i++){
			for (j=0; j<S-3; j++){
				if(cudaMemcpy(flagExtrema[i][j],GPUflagExtrema[i][j],sizeof(int)*octavesW[i]*octavesH[i],cudaMemcpyDeviceToHost)!=cudaSuccess){
						cudaError_t error = cudaGetLastError();
						printf ("cudaMemcpyDeviceToHost Error! GPUflagExtrema[%d][%d]\tCUDA error: %s\n",i,j,cudaGetErrorString(error));
						cudaFree(GPUflagExtrema);
				}
				//openShow3((unsigned char*)flagExtrema[i][j],octavesH[i],octavesW[i],"FLAGEXTREMA");
			}
		}
		logtime2("GPU memcpy to host end");
		printf("\tGPUflagExtrema downloaded from GPU, O=%d, S=%d\n",i,j);
		logtime2("CPU edge start");
		for (i=0; i<O; i++){
			for (j=0; j<S-3; j++){
				/*if(cudaMemcpy(flagEdge[i][j],GPUflagEdge[i][j],sizeof(int)*octavesW[i]*octavesH[i],cudaMemcpyDeviceToHost)!=cudaSuccess){
						cudaError_t error = cudaGetLastError();
						printf ("cudaMemcpyDeviceToHost Error! GPUflagEdge[%d][%d]\tCUDA error: %s\n",i,j,cudaGetErrorString(error));
						cudaFree(GPUflagEdge);
				}*/
//BUG: becasue the GPUcheckEdge does not work, instead of copying it, launch TESTcheckEdge, when fixed, remove next line and uncomment the above loop 
				TESTcheckEdge(dog[i][j+1],octavesW[i], octavesH[i], flagExtrema[i][j],flagEdge[i][j]);
				//openShow3((unsigned char*)flagEdge[i][j],octavesH[i],octavesW[i],"FLAGEDGE");
			}
		}
		logtime2("CPU edge end");
		printf("\tGPUflagEdge downloaded from GPU, O=%d, S=%d\n",i,j);

//sift keygen
		logtime2("CPU sift keygen start");
		for(i = 0; i < O; i++){
			//printf("\t\tSIFT key search O:%d ",i);
			for(j = 0; j < S-3; j++){
					//printf("S:%d\n",j);
					siftkeygen(flagEdge[i][j], flagExtrema[i][j],octavesW[i],octavesH[i],i,j, keyHead, keyN);		//isws xreiastei dereferencing
					//printf ("\t\t\tran siftkeygen for O=%d, S=%d \n",i,j);
			}
		}
		logtime2("CPU sift keygen end");
		printf("GPUextreme complete.\n");
		logtime2("GPUextreme end");
	}//GPUextreme
}//extern C

/**********************************************
 * checkExtrema:
 * check whether a given pixel is extreme pt.
 *
 * Parameters
 * self: input, self scale in dog
 * up: input, upper scale in dog
 * down: input, lower scale in dog
 * w: input, width of the octave
 * h: input, height of the octave
 * r: input, row (y) of the pt. to be checked
 * c: input, column (x) of the pt. to be checked
 * flagExtrema: output, whether (r,c) is extrema
 *********************************************/
extern "C"{
	//this kernel works
	__global__ void GPUcheckExtrema(float* inself, float *inup, float* indown,int inW,int inH, float inradius,float inpeakThres,int* outflagExtrema){
						const int x=blockIdx.x*blockDim.x+threadIdx.x;
						const int y=blockIdx.y*blockDim.y+threadIdx.y;

						if ((x>(int)inradius) && (x<inW-(int)inradius-1) && (y>(int)inradius) && (y<inH-(int)inradius-1))	//for loop boundaries
						{
							
							if( 
								( inself[y*inW+x] < -1.0 * inpeakThres &&
								  inself[y*inW+x] < inself[(y-1)*inW+x-1] &&
								  inself[y*inW+x] < inself[(y-1)*inW+x] &&
								  inself[y*inW+x] < inself[(y-1)*inW+x+1] &&
								  inself[y*inW+x] < inself[y*inW+x-1] &&
								  inself[y*inW+x] < inself[y*inW+x+1] &&
								  inself[y*inW+x] < inself[(y+1)*inW+x-1] &&
								  inself[y*inW+x] < inself[(y+1)*inW+x] &&
								  inself[y*inW+x] < inself[(y+1)*inW+x+1] &&
								  inself[y*inW+x] < inup[(y-1)*inW+x-1] &&
								  inself[y*inW+x] < inup[(y-1)*inW+x] &&
								  inself[y*inW+x] < inup[(y-1)*inW+x+1] &&
								  inself[y*inW+x] < inup[y*inW+x-1] &&
								  inself[y*inW+x] < inup[y*inW+x] &&
								  inself[y*inW+x] < inup[y*inW+x+1] &&
								  inself[y*inW+x] < inup[(y+1)*inW+x-1] &&
								  inself[y*inW+x] < inup[(y+1)*inW+x] &&
								  inself[y*inW+x] < inup[(y+1)*inW+x+1] &&
								  inself[y*inW+x] < indown[(y-1)*inW+x-1] &&
								  inself[y*inW+x] < indown[(y-1)*inW+x] &&
								  inself[y*inW+x] < indown[(y-1)*inW+x+1] &&
								  inself[y*inW+x] < indown[y*inW+x-1] &&
								  inself[y*inW+x] < indown[y*inW+x] &&
								  inself[y*inW+x] < indown[y*inW+x+1] &&
								  inself[y*inW+x] < indown[(y+1)*inW+x-1] &&
								  inself[y*inW+x] < indown[(y+1)*inW+x] &&
								  inself[y*inW+x] < indown[(y+1)*inW+x+1] )
								||
								( inself[y*inW+x] > inpeakThres &&
								  inself[y*inW+x] > inself[(y-1)*inW+x-1] &&
								  inself[y*inW+x] > inself[(y-1)*inW+x] &&
								  inself[y*inW+x] > inself[(y-1)*inW+x+1] &&
								  inself[y*inW+x] > inself[y*inW+x-1] &&
								  inself[y*inW+x] > inself[y*inW+x+1] &&
								  inself[y*inW+x] > inself[(y+1)*inW+x-1] &&
								  inself[y*inW+x] > inself[(y+1)*inW+x] &&
								  inself[y*inW+x] > inself[(y+1)*inW+x+1] &&
								  inself[y*inW+x] > inup[(y-1)*inW+x-1] &&
								  inself[y*inW+x] > inup[(y-1)*inW+x] &&
								  inself[y*inW+x] > inup[(y-1)*inW+x+1] &&
								  inself[y*inW+x] > inup[y*inW+x-1] &&
								  inself[y*inW+x] > inup[y*inW+x] &&
								  inself[y*inW+x] > inup[y*inW+x+1] &&
								  inself[y*inW+x] > inup[(y+1)*inW+x-1] &&
								  inself[y*inW+x] > inup[(y+1)*inW+x] &&
								  inself[y*inW+x] > inup[(y+1)*inW+x+1] &&
								  inself[y*inW+x] > indown[(y-1)*inW+x-1] &&
								  inself[y*inW+x] > indown[(y-1)*inW+x] &&
								  inself[y*inW+x] > indown[(y-1)*inW+x+1] &&
								  inself[y*inW+x] > indown[y*inW+x-1] &&
								  inself[y*inW+x] > indown[y*inW+x] &&
								  inself[y*inW+x] > indown[y*inW+x+1] &&
								  inself[y*inW+x] > indown[(y+1)*inW+x-1] &&
								  inself[y*inW+x] > indown[(y+1)*inW+x] &&
								  inself[y*inW+x] > indown[(y+1)*inW+x+1] )
								){
								outflagExtrema[y*inW+x] = FLAGYES;
							}else{
								outflagExtrema[y*inW+x] = 0;
							}//else


						}//valid threads

	}//GPUcheckExtrema
}//extern C

/**********************************************
 * checkEdge:
 * check whether a given pixel is edge
 *
 * Parameters
 * dogImg: input, diff of gaussian image
 * w: input, width of the octave
 * h: input, height of the octave
 * r: input, row (y) of the pt. to be checked
 * c: input, column (x) of the pt. to be checked
 * flagEdge: output, whether (r,c) is edge
 *********************************************/
extern "C"{
//BUG this kernel does not work, and is the reason for the above modifications noted as "BUG"
	__global__ void GPUcheckEdge(float* inself,int inW,int inH,int* inflagExtrema, int* outflagEdge){

				const int x=blockIdx.x*blockDim.x+threadIdx.x;
				const int y=blockIdx.y*blockDim.y+threadIdx.y;

				if (x<inW && y<inH)	//valid threads
					{
						if (inflagExtrema[y*inW+x]==FLAGYES){
							float dxx, dyy, dxy;
							float center = inself[y*inW+x];
							float left = inself[y*inW+x-1];
							float right = inself[y*inW+x+1];
							float up = inself[(y-1)*inW+x];
							float down = inself[(y+1)*inW+x];
							float upleft = inself[(y-1)*inW+x-1];
							float upright = inself[(y-1)*inW+x+1];
							float downleft = inself[(y+1)*inW+x-1];
							float downright = inself[(y+1)*inW+x+1];
							float trace, det, curv, K;

							// derivative with neighbor pixel
							dxx = right + left - 2.0f * center;
							dyy = up + down - 2.0f * center;
							// derivative with stride-of-two pixels
							// then averaged by two
							dxy = ( (upright - upleft)/2.0f -
									(downright - downleft)/2.0f ) / 2.0f;

							trace = dxx + dyy;
							det = dxx * dyy - dxy * dxy;
							curv = CURVATURE_THRESHOLD;
							K = curv / ((curv+1.0f)*(curv+1.0f));

							if(trace * trace / det < 1.0f / K){
								outflagEdge[y*inW+x] = FLAGYES;
							}else{
								outflagEdge[y*inW+x] = 0;
							}//if trace..
						}//if flagExtrema
				}//valid threads
	}//GPUcheckEdge
}//extern C


extern "C"{
	//this is the temporary function to bypass the GPUcheckEdge bug
	void TESTcheckEdge(float* inself,int inW,int inH,int* inflagExtrema, int* outflagEdge){
		int x, y;
		for (y=0;y<inH;y++){
			for (x=0;x<inW;x++){
				if(inflagExtrema[y*inW+x]==FLAGYES){

					float dxx, dyy, dxy;
					float center = inself[y*inW+x];
					float left = inself[y*inW+x-1];
					float right = inself[y*inW+x+1];
					float up = inself[(y-1)*inW+x];
					float down = inself[(y+1)*inW+x];
					float upleft = inself[(y-1)*inW+x-1];
					float upright = inself[(y-1)*inW+x+1];
					float downleft = inself[(y+1)*inW+x-1];
					float downright = inself[(y+1)*inW+x+1];
					float trace, det, curv, K;

					// derivative with neighbor pixel
					dxx = right + left - 2.0f * center;
					dyy = up + down - 2.0f * center;
					// derivative with stride-of-two pixels
					// then averaged by two
					dxy = ( (upright - upleft)/2.0f -
							(downright - downleft)/2.0f ) / 2.0f;

					trace = dxx + dyy;
					det = dxx * dyy - dxy * dxy;
					curv = CURVATURE_THRESHOLD;
					K = curv / ((curv+1.0f)*(curv+1.0f));

					if(trace * trace / det < 1.0f / K){
						outflagEdge[y*inW+x] = FLAGYES;
					}else{
						outflagEdge[y*inW+x] = 0;
					}//if trace..
				}//if flagExtrema
			}//for x
		}//for y
				
	}//TESTcheckEdge
}//extern C


extern "C"{
	//this function works
	void siftkeygen(int* inflagEdge, int* inflagExtrema, int inW, int inH, int i, int j,pointList** keyHead, int* keyN){
		int x=0;
		int y=0;
		pointList* tmp;
		//printf("\tChecking for SIFTkeys, inW=%d\tinH=%d\n",inW,inH);

		for (y=0;y<inH;y++){
			//printf("\t\t\t\t\t\tx=%d ",x);
			for (x=0;x<inW;x++){
				//printf("y=%d ",y);
				//if(inflagExtrema[y*inW+x] == FLAGYES){
					//printf ("\t\t\textremum found\tx:%d\ty:%d\n",x,y);
					//if(inflagEdge[y*inW+x] != FLAGYES){
					if(inflagEdge[y*inW+x] == FLAGYES){				//if point is flagged as belonging to an edge-ignore kpt registration
						//printf ("\t\t\t\tSIFTkey found\tx:%d\ty:%d\n",x,y);
								if(*keyN == 0){
									// create head
									(*keyHead) = 
										(pointList*)
										malloc
										(sizeof
										 (pointList));
									(*keyHead)->self.o =
										i;
									(*keyHead)->self.s = 
										(float)j;
									(*keyHead)->self.x = 
										(float)x;
									(*keyHead)->self.y = 
										(float)y;
									(*keyHead)->self.ori=
										0.0f;
									(*keyHead)->next = 
										NULL;
								}else{
									// insert from head
									
									tmp =
										(pointList*)
										malloc(
											sizeof
											(pointList));
									tmp->self.o = 
										i;
									tmp->self.s = 
										(float)j;
									tmp->self.x = 
										(float)x;
									tmp->self.y = 
										(float)y;
									tmp->self.ori = 
										0.0f;
									tmp->next = 
										(*keyHead);
									(*keyHead) = 
										tmp;
								}//if *keyN
								*keyN = *keyN+1;
					}//if flagEdge
				//}//if flagExtrema
			}//for x
			//printf("\n");
		}//for y
	}

}

extern "C"{
	//this kernel does not work, it is the stitched 2 kernels above as an attempt to locate the BUG

	__global__ void GPUcheckEE(float* inself, float *inup, float* indown,int inW,int inH, float inradius,float inpeakThres,int* outflagEdge){
						const int x=blockIdx.x*blockDim.x+threadIdx.x;
						const int y=blockIdx.y*blockDim.y+threadIdx.y;
						int extremumflag;

						if ((x>(int)inradius) && (x<inW-(int)inradius-1) && (y>(int)inradius) && (y<inH-(int)inradius-1))	//for loop boundaries
						{
							
							if( 
								( inself[y*inW+x] < -1.0 * inpeakThres &&
								  inself[y*inW+x] < inself[(y-1)*inW+x-1] &&
								  inself[y*inW+x] < inself[(y-1)*inW+x] &&
								  inself[y*inW+x] < inself[(y-1)*inW+x+1] &&
								  inself[y*inW+x] < inself[y*inW+x-1] &&
								  inself[y*inW+x] < inself[y*inW+x+1] &&
								  inself[y*inW+x] < inself[(y+1)*inW+x-1] &&
								  inself[y*inW+x] < inself[(y+1)*inW+x] &&
								  inself[y*inW+x] < inself[(y+1)*inW+x+1] &&
								  inself[y*inW+x] < inup[(y-1)*inW+x-1] &&
								  inself[y*inW+x] < inup[(y-1)*inW+x] &&
								  inself[y*inW+x] < inup[(y-1)*inW+x+1] &&
								  inself[y*inW+x] < inup[y*inW+x-1] &&
								  inself[y*inW+x] < inup[y*inW+x] &&
								  inself[y*inW+x] < inup[y*inW+x+1] &&
								  inself[y*inW+x] < inup[(y+1)*inW+x-1] &&
								  inself[y*inW+x] < inup[(y+1)*inW+x] &&
								  inself[y*inW+x] < inup[(y+1)*inW+x+1] &&
								  inself[y*inW+x] < indown[(y-1)*inW+x-1] &&
								  inself[y*inW+x] < indown[(y-1)*inW+x] &&
								  inself[y*inW+x] < indown[(y-1)*inW+x+1] &&
								  inself[y*inW+x] < indown[y*inW+x-1] &&
								  inself[y*inW+x] < indown[y*inW+x] &&
								  inself[y*inW+x] < indown[y*inW+x+1] &&
								  inself[y*inW+x] < indown[(y+1)*inW+x-1] &&
								  inself[y*inW+x] < indown[(y+1)*inW+x] &&
								  inself[y*inW+x] < indown[(y+1)*inW+x+1] )
								||
								( inself[y*inW+x] > inpeakThres &&
								  inself[y*inW+x] > inself[(y-1)*inW+x-1] &&
								  inself[y*inW+x] > inself[(y-1)*inW+x] &&
								  inself[y*inW+x] > inself[(y-1)*inW+x+1] &&
								  inself[y*inW+x] > inself[y*inW+x-1] &&
								  inself[y*inW+x] > inself[y*inW+x+1] &&
								  inself[y*inW+x] > inself[(y+1)*inW+x-1] &&
								  inself[y*inW+x] > inself[(y+1)*inW+x] &&
								  inself[y*inW+x] > inself[(y+1)*inW+x+1] &&
								  inself[y*inW+x] > inup[(y-1)*inW+x-1] &&
								  inself[y*inW+x] > inup[(y-1)*inW+x] &&
								  inself[y*inW+x] > inup[(y-1)*inW+x+1] &&
								  inself[y*inW+x] > inup[y*inW+x-1] &&
								  inself[y*inW+x] > inup[y*inW+x] &&
								  inself[y*inW+x] > inup[y*inW+x+1] &&
								  inself[y*inW+x] > inup[(y+1)*inW+x-1] &&
								  inself[y*inW+x] > inup[(y+1)*inW+x] &&
								  inself[y*inW+x] > inup[(y+1)*inW+x+1] &&
								  inself[y*inW+x] > indown[(y-1)*inW+x-1] &&
								  inself[y*inW+x] > indown[(y-1)*inW+x] &&
								  inself[y*inW+x] > indown[(y-1)*inW+x+1] &&
								  inself[y*inW+x] > indown[y*inW+x-1] &&
								  inself[y*inW+x] > indown[y*inW+x] &&
								  inself[y*inW+x] > indown[y*inW+x+1] &&
								  inself[y*inW+x] > indown[(y+1)*inW+x-1] &&
								  inself[y*inW+x] > indown[(y+1)*inW+x] &&
								  inself[y*inW+x] > indown[(y+1)*inW+x+1] )
								){
								extremumflag = FLAGYES;
							}else{
								extremumflag = 0;
							}//else

							if (extremumflag==FLAGYES){
								float dxx, dyy, dxy;
								float center = inself[y*inW+x];
								float left = inself[y*inW+x-1];
								float right = inself[y*inW+x+1];
								float up = inself[(y-1)*inW+x];
								float down = inself[(y+1)*inW+x];
								float upleft = inself[(y-1)*inW+x-1];
								float upright = inself[(y-1)*inW+x+1];
								float downleft = inself[(y+1)*inW+x-1];
								float downright = inself[(y+1)*inW+x+1];
								float trace, det, curv, K;

								// derivative with neighbor pixel
								dxx = right + left - 2.0f * center;
								dyy = up + down - 2.0f * center;
								// derivative with stride-of-two pixels
								// then averaged by two
								dxy = ( (upright - upleft)/2.0f -
										(downright - downleft)/2.0f ) / 2.0f;

								trace = dxx + dyy;
								det = dxx * dyy - dxy * dxy;
								curv = CURVATURE_THRESHOLD;
								K = curv / ((curv+1.0f)*(curv+1.0f));

								if(trace * trace / det < 1.0f / K){
										//outflagEdge[y*inW+x] = 0;
									outflagEdge[y*inW+x] = FLAGYES;
								}else{
										//outflagEdge[y*inW+x] = FLAGYES;
									outflagEdge[y*inW+x] = 0;
								}//if trace..
							}//if extremumflag


						}//valid threads

	}//GPUcheckEE
}//extern C