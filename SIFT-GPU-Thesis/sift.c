#include "sift.h"
#include "timer.h"
#include "img_io.h"

#undef DUMP_OCTAVE
#undef DUMP_SCALESPACE
#undef DUMP_DOG

	//OPENCV IN-OUT HANDLING INCLUDES
	#include "ioocv.h"
	#include <opencv\cv.h>
	#include <opencv\highgui.h> 
	#include <opencv\cxcore.h>
	#include "MYtimer.h"

void
sift(unsigned char* img, int w, int h, char* out_filename) {
  
    /************************
     * Common Variables
     ***********************/
    Timer totalTime;
    int i, j;
	char labelcall [200];//DEBUG WINDOW LABEL

#if (defined DUMP_OCTAVE || defined DUMP_SCALESPACE || defined DUMP_DOG)
    // file name
    char tmpfile[10];
#endif
    /************************
     * Global Variables
     ***********************/
    // number of total octaves
    int O;
    // number of scales per octaves
    int S;
    // width of each octave
    int octavesW[MAX_O];
    // height of each octave
    int octavesH[MAX_O];
    // sigma at each scale
    float sigma0 = 1.6f;
    float sigmas[MAX_O][MAX_S];
    // number of keys in linked list
    int keyN = 0;
    FILE *skey;
    /************************
     * Data Structures
     ***********************/

    // octaves generated by down sampling
    unsigned char* octaves[MAX_O];
    // scale space
    float* scaleSpace[MAX_O][MAX_S];
    // difference of gaussians
    float* dog[MAX_O][MAX_S-1];
    // extreme points
    pointList* keyHead, * keyPtr;

    /************************
     * Variable computation
     ***********************/
	logtime("CPU CPU-variable computation start");
    // number of octaves (skip last two level)
    O = (int)(log2( (w < h) ? (float)w : (float)h))-2;		//TODO: explain this syntax
    // scales per octaves (empirical number)
    S = 6;
    // width of octaves at each level
    octavesW[0] = w;
    for(i = 1; i < O; i++){
        octavesW[i] = octavesW[i-1]/2;
    }
    // height of octaves at each level
    octavesH[0] = h;
    for(i = 1; i < O; i++){
        octavesH[i] = octavesH[i-1]/2;
    }
    // gaussian sigmas at each scale
    for(i = 0; i < O; i++){
        for(j = 0; j < S; j++){
            sigmas[i][j] = sigma0 * pow(sqrt(2.0f), (float)j/(float)(S-3) );
        }
    }
	logtime("CPU CPU-variable computation end");

#if VERBOSE == 1
    printf("Image size: %dx%d\n", w, h);
    printf("Number of octaves (O):%d\n", O);
    printf("Scales per octave (S):%d\n", S);
    for(i = 0; i < O; i++){
        printf("size of octave level %d: %dx%d\n", i, octavesW[i], octavesH[i]);
    }
#endif

    /*******************************
     * start the timer
     *******************************/
    start_timer(&totalTime);
    /************************
     * Memory Allocation
     ***********************/
	logtime("CPU CPU-malloc start");
    // octaves
    for(i = 0; i < O; i++){
        octaves[i] = (unsigned char*)
            malloc(octavesW[i] * octavesH[i] * sizeof(unsigned char));
    }
    // scale sapce
    for(i = 0; i < O; i++){
        for(j = 0; j < S; j++){
            scaleSpace[i][j] =
                (float*)malloc(octavesW[i] * octavesH[i] * sizeof(float));
        }
    }
    // difference of gaussians
    for(i = 0; i < O; i++){
        for(j = 0; j < S-1; j++){
            dog[i][j] = 
                (float*)malloc( octavesW[i] * octavesH[i] * sizeof(float));
        }
    }
    logtime("CPU CPU-malloc end");

    /************************
     * Step 1:
     * Build Octave Base by downsampling
     ***********************/
		printf("\n *** CPU: STEP 1 : BUILD OCTAVE BASE BY DOWNSAMPLING.*** \n");
		logtime("CPU buildOB-start");
    buildOB(img, octaves, O, S, octavesW, octavesH);
		logtime("CPU buildOB-end");

//OPENCV VIEW/SAVE DEBUG
		for(i=0;i<O;i++){
				sprintf(labelcall,"CPU octave %02d",i);
				openShow(octaves[i],octavesH[i], octavesW[i], labelcall);
				//sprintf(labelcall,"producedImages/01CPU octave%02d.jpg",i);
				//openSave(octaves[i],octavesH[i], octavesW[i], labelcall);
		}

#ifdef DUMP_OCTAVE
    for(i = 0; i < O; i++){
        sprintf(tmpfile,"%s%d%s", "OB", i, ".pgm");
        write_pgm(octaves[i], octavesW[i], octavesH[i], tmpfile);
    }
#endif

    /************************
     * Step 2:
     * Build Scale Space by Gaussian
     ***********************/
		printf("\n*** CPU: STEP 2 : BUILD SCALE SPACE BY GAUSSIAN.*** \n");
		logtime("CPU buildSS-start");
    buildSS(octaves, scaleSpace, O, S, octavesW, octavesH, sigmas);
		logtime("CPU buildSS-end");

//OPENCV VIEW/SAVE DEBUG
		for (i=0;i<O;i++){//for each octave
			for (j=0;j<S;j++){
				//printf("debug show/save O%d S%d\n",i,j);
				sprintf(labelcall,"producedImages/02CPUscaleSpace O%02d S%02d.jpg",i,j);
				openSaveFloat(scaleSpace[i][j],labelcall,octavesH[i],octavesW[i]);
				//sprintf(labelcall,"CPUsS O%02d S%02d",i,j);
				//openShowFloat(scaleSpace[i][j],labelcall,octavesH[i],octavesW[i]);
			}
		}

#ifdef DUMP_SCALESPACE
    for(i = 0; i < O; i++){
        for(j = 0; j < S; j++){
            sprintf(tmpfile, "%s%d%d%s", "SS", i, j, ".pgm");
            write_float_pgm(scaleSpace[i][j],octavesW[i],octavesH[i],tmpfile,1);
        }
    }
#endif

    /************************
     * Step 3:
     * Difference of Gaussians (DoG)
     ***********************/
		printf("\n*** CPU: STEP 3 : DIFFERENCE OF GAUSSIANS.*** \n");
		logtime("CPU DoG-start");
    DoG(dog, scaleSpace, O, S, octavesW, octavesH);
		logtime("CPU DoG-end");

//OPENCV VIEW/SAVE DEBUG
		for (i=0;i<O;i++){//for each octave
			for (j=0;j<S-1;j++){
				sprintf(labelcall,"producedImages/03CPUDoG O%02d S%02d.jpg",i,j);
				openSaveFloat(dog[i][j],labelcall,octavesH[i],octavesW[i]);
				//sprintf(labelcall,"CPUDoG O%02d S%02d",i,j);
				//openShowFloat(dog[i][j],labelcall,octavesH[i],octavesW[i]);
			}
		}
		
#ifdef DUMP_DOG
    for(i = 0; i < O; i++){
        for(j = 0; j < S-1; j++){
            sprintf(tmpfile,"%s%d%d%s", "DoG", i, j, ".pgm");
            write_float_pgm(dog[i][j], octavesW[i], octavesH[i], tmpfile, 2);
        }
    }
#endif

    /************************
     * Step 4:
     * Find extreme points
     ***********************/
		printf("\n*** CPU: STEP 4 : EXTREMA SEARCH.*** \n");
    extreme(&keyHead, &keyN, dog, O, S, octavesW, octavesH);

    /************************
     * Keypoint Orientation
     ***********************/
		printf("\n*** GPU: STEP 5 : KEYPOINT ORIENTATION.*** \n");
    orientation(keyHead, scaleSpace, sigmas, octavesW, octavesH);

#if VERBOSE == 1
    printf("Detect %d keypoints\n", keyN);
    skey = fopen("skey","w");
    keyPtr = keyHead;
    fprintf(skey, "%d\t%d\n", keyN, 4);
			logtime2("CPU orientation start");
    for(i = 0; i < keyN; i++){
        fprintf(skey, "%f\t%f\t%f\t%f\n", keyPtr->self.x, keyPtr->self.y,
                keyPtr->self.s, keyPtr->self.ori);
        keyPtr = keyPtr->next;
    }
			logtime2("CPU orientation end");
    fclose(skey);
    printf
        ("Output 4 element descriptor to file: skey\n");
#endif

    /*******************************
     * All actual processing done,
     * stop the timer
     *******************************/
		printf("\n### CPU: PROCCESSING COMPLETE.### \n");
    stop_timer(&totalTime);
    printf("Total time: %f ms\n", get_timer_interval(&totalTime));
    /************************
     * Render Results
     * Draw circle around keypoints
     * (to do: draw the orientation)
     ***********************/
		printf("\n### CPU: RENDERING RESULTS.### \n");
    render(img, out_filename, O, S, octavesW, octavesH, keyHead, keyN, sigmas);

    /************************
     * Free Memory
     ***********************/
    for(i = 0; i < O; i++){
        free(octaves[i]);
        for(j = 0; j < S; j++){
            free(scaleSpace[i][j]);
            if(j < S-1){
                free(dog[i][j]);
            }
        }
    }
		printf("---CPU: SIFT COMPLETE--- \n");
}// sift()
